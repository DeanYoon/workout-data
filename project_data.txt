===== FILE: .gitignore =====
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


*.md
*.py
package-lock.json


===== FILE: eslint.config.mjs =====
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;



===== FILE: next-env.d.ts =====
/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



===== FILE: next.config.ts =====
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async headers() {
    return [
      {
        // 모든 경로에 보안 헤더 적용
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on',
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload',
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block',
          },
          {
            key: 'Referrer-Policy',
            value: 'origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()',
          },
        ],
      },
    ];
  },
};

export default nextConfig;



===== FILE: postcss.config.mjs =====
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;



===== FILE: tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"],
      "@/types/*": ["./src/types/*"],
      "@/types": ["./src/types"],
      "@/lib/*": ["./src/lib/*"],
      "@/stores/*": ["./src/stores/*"],
      "@/stores": ["./src/stores"],
      "@/utils/*": ["./src/utils/*"],
      "@/utils": ["./src/utils/index"],
      "@/services/*": ["./src/services/*"],
      "@/services": ["./src/services"],
      "@/components/*": ["./src/components/*"],
      "@/components": ["./src/components"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}



===== FILE: app\globals.css =====
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* Hide scrollbar for all browsers */
* {
  scrollbar-width: none;
  /* Firefox */
  -ms-overflow-style: none;
  /* IE and Edge */
}

*::-webkit-scrollbar {
  display: none;
  /* Chrome, Safari, Opera */
}

html {
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  text-size-adjust: 100%;
}


===== FILE: app\layout.tsx =====
import type { Metadata, Viewport } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AuthProvider, ThemeProvider, I18nProvider, BottomNavigation, ErrorBoundary } from "@/components";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Fitness App",
  description: "Track your workout and progress",
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-zinc-50 dark:bg-zinc-950 text-zinc-900 dark:text-zinc-100`}
      >
        <ThemeProvider>
          <I18nProvider>
            <ErrorBoundary>
              <AuthProvider>
                <div className="mx-auto min-h-screen max-w-md bg-white shadow-2xl dark:bg-black dark:shadow-zinc-900/20">
                <main className="min-h-screen pb-20">
                  {children}
                </main>
                <BottomNavigation />
              </div>
              </AuthProvider>
            </ErrorBoundary>
          </I18nProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}



===== FILE: app\(routes)\page.tsx =====
"use client";

import { useState, useEffect } from "react";
import { useTranslation } from "react-i18next";
import { useHomeDataStore, useUserStore } from "@/stores";
import { getWorkoutByName } from "@/services";
import {
  WeeklyGoalProgress,
  SplitConfig,
  WeeklySchedule,
  TodayWorkoutCard,
  ActiveSessionDrawer,
  type ExerciseItem,
} from "@/components";

export default function Home() {
  const { t } = useTranslation();
  const [isWorkoutActive, setIsWorkoutActive] = useState(false);
  const [activeSessionInitialData, setActiveSessionInitialData] = useState<ExerciseItem[] | undefined>(undefined);
  const [activeSessionInitialName, setActiveSessionInitialName] = useState<string | undefined>(undefined);
  const { homeData, isLoading, refreshHomeData, fetchHomeData } = useHomeDataStore();

  useEffect(() => {
    fetchHomeData();
  }, [fetchHomeData]);

  const handleStartWorkout = async (workoutName: string) => {
    try {
      const userId = await useUserStore.getState().getUserId();
      const workout = await getWorkoutByName(userId, workoutName);

      if (workout) {
        const initialData: ExerciseItem[] = workout.exercises.map((ex) => ({
          id: crypto.randomUUID(),
          name: ex.name,
          sets: ex.sets.map((set) => ({
            id: crypto.randomUUID(),
            weight: set.weight,
            reps: set.reps,
            isCompleted: false,
          })),
        }));

        setActiveSessionInitialData(initialData);
        setActiveSessionInitialName(workoutName);
        setIsWorkoutActive(true);
      } else {
        setActiveSessionInitialData(undefined);
        setActiveSessionInitialName(workoutName);
        setIsWorkoutActive(true);
      }
    } catch (error) {
      console.error("Error starting workout:", error);
      setActiveSessionInitialData(undefined);
      setActiveSessionInitialName(workoutName);
      setIsWorkoutActive(true);
    }
  };

  const handleDataRefresh = () => {
    refreshHomeData();
  };

  if (isLoading) {
    return (
      <div className="p-4">
        <h1 className="text-2xl font-bold mb-4 text-zinc-900 dark:text-zinc-100">{t('home.title')}</h1>
        <div className="space-y-4">
          <div className="h-20 bg-zinc-100 dark:bg-zinc-900 rounded-2xl animate-pulse" />
          <div className="h-20 bg-zinc-100 dark:bg-zinc-900 rounded-2xl animate-pulse" />
          <div className="h-20 bg-zinc-100 dark:bg-zinc-900 rounded-2xl animate-pulse" />
        </div>
      </div>
    );
  }

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4 text-zinc-900 dark:text-zinc-100">{t('home.title')}</h1>
      {homeData && (
        <>
          <WeeklyGoalProgress
            weeklyGoal={homeData.weeklyGoal}
            weekWorkouts={homeData.weekWorkouts}
            onDataChange={handleDataRefresh}
          />
          <SplitConfig
            splitConfig={homeData.splitConfig}
            workoutNames={homeData.workoutNames}
            onDataChange={handleDataRefresh}
          />
          <WeeklySchedule
            splitOrder={homeData.splitConfig?.split_order ?? []}
            weekWorkouts={homeData.weekWorkouts}
            allWorkouts={homeData.allWorkouts}
          />
          <TodayWorkoutCard
            splitOrder={homeData.splitConfig?.split_order ?? []}
            weekWorkouts={homeData.weekWorkouts}
            todayWorkout={homeData.todayWorkout}
            todayWorkoutDetail={homeData.todayWorkoutDetail}
            onStartWorkout={handleStartWorkout}
          />
        </>
      )}

      <ActiveSessionDrawer
        isOpen={isWorkoutActive}
        onClose={() => {
          setIsWorkoutActive(false);
          setActiveSessionInitialData(undefined);
          setActiveSessionInitialName(undefined);
          handleDataRefresh();
        }}
        initialData={activeSessionInitialData}
        initialWorkoutName={activeSessionInitialName}
      />
    </div>
  );
}



===== FILE: app\(routes)\data\page.tsx =====
'use client';

import { useState, useMemo, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useWorkoutAnalyticsStore, useExerciseHistoryStore, type DateAnalytics } from '@/stores';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Dot } from 'recharts';
import { format, parseISO } from '@/utils';
import { ChevronDown } from 'lucide-react';

type MetricType = 'maxWeight' | 'maxVolume' | 'totalVolume';
type ViewType = 'chart' | 'history';

export default function DataPage() {
  const { t } = useTranslation();

  const METRIC_LABELS: Record<MetricType, string> = {
    maxWeight: t('data.maxWeight'),
    maxVolume: t('data.maxVolume'),
    totalVolume: t('data.totalVolume'),
  };
  const { data, isLoading, error, isLoaded, fetchAnalytics } = useWorkoutAnalyticsStore();
  const { exerciseHistory, isLoading: isHistoryLoading, fetchExerciseHistory, clearHistory } = useExerciseHistoryStore();

  useEffect(() => {
    // Only fetch if not already loaded
    if (!isLoaded) {
      fetchAnalytics();
    }
  }, [isLoaded, fetchAnalytics]);

  const [selectedExercise, setSelectedExercise] = useState<string>('');
  const [selectedMetric, setSelectedMetric] = useState<MetricType>('maxWeight');
  const [viewType, setViewType] = useState<ViewType>('chart');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  // Fetch exercise history when exercise is selected and view is history
  useEffect(() => {
    if (selectedExercise && viewType === 'history') {
      fetchExerciseHistory(selectedExercise);
    }
    // Don't clear history when switching to chart view - keep it cached
  }, [selectedExercise, viewType, fetchExerciseHistory]);

  // Get available exercises and find the most recent one
  const availableExercises = useMemo(() => {
    return Object.keys(data).sort();
  }, [data]);

  const mostRecentExercise = useMemo(() => {
    if (availableExercises.length === 0) return '';

    let mostRecent = availableExercises[0];
    let mostRecentDate = '';

    availableExercises.forEach((exercise) => {
      const exerciseData = data[exercise];
      if (exerciseData.length > 0) {
        const lastDate = exerciseData[exerciseData.length - 1].date;
        if (!mostRecentDate || lastDate > mostRecentDate) {
          mostRecentDate = lastDate;
          mostRecent = exercise;
        }
      }
    });

    return mostRecent;
  }, [data, availableExercises]);

  // Set default exercise when data loads
  useMemo(() => {
    if (mostRecentExercise && !selectedExercise) {
      setSelectedExercise(mostRecentExercise);
    }
  }, [mostRecentExercise, selectedExercise]);

  // Get chart data for selected exercise and metric
  const chartData = useMemo(() => {
    if (!selectedExercise || !data[selectedExercise]) return [];

    return data[selectedExercise].map((entry: DateAnalytics) => ({
      date: entry.date,
      value: entry[selectedMetric],
      formattedDate: format(parseISO(entry.date), 'MM/dd'),
    }));
  }, [selectedExercise, selectedMetric, data]);

  // Calculate summary stats
  const summaryStats = useMemo(() => {
    if (!selectedExercise || !data[selectedExercise] || data[selectedExercise].length === 0) {
      return { personalBest: 0, totalRecords: 0 };
    }

    const exerciseData = data[selectedExercise];
    const personalBest = Math.max(...exerciseData.map((entry) => entry.maxWeight));
    const totalRecords = exerciseData.length;

    return { personalBest, totalRecords };
  }, [selectedExercise, data]);

  if (isLoading) {
    return (
      <div className="relative min-h-screen bg-zinc-50 pb-24 dark:bg-black">
        <div className="sticky top-0 z-10 border-b bg-white/80 p-4 backdrop-blur-md dark:border-zinc-800 dark:bg-black/80 z-50">
          <h1 className=" text-2xl font-bold tracking-tight text-zinc-900 dark:text-zinc-100">{t('data.title')}</h1>
        </div>
        <div className="p-4 space-y-4">
          {/* Exercise Selector Skeleton */}
          <div>
            <div className="h-4 w-16 bg-zinc-200 rounded mb-2 animate-pulse dark:bg-zinc-800"></div>
            <div className="h-12 w-full bg-zinc-200 rounded-xl animate-pulse dark:bg-zinc-800"></div>
          </div>
          {/* Metric Selector Skeleton */}
          <div>
            <div className="h-4 w-16 bg-zinc-200 rounded mb-2 animate-pulse dark:bg-zinc-800"></div>
            <div className="flex gap-2">
              <div className="flex-1 h-12 bg-zinc-200 rounded-xl animate-pulse dark:bg-zinc-800"></div>
              <div className="flex-1 h-12 bg-zinc-200 rounded-xl animate-pulse dark:bg-zinc-800"></div>
              <div className="flex-1 h-12 bg-zinc-200 rounded-xl animate-pulse dark:bg-zinc-800"></div>
            </div>
          </div>
          {/* Chart Skeleton */}
          <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
            <div className="h-[300px] bg-zinc-200 rounded animate-pulse dark:bg-zinc-800"></div>
          </div>
          {/* Summary Cards Skeleton */}
          <div className="grid grid-cols-2 gap-3">
            <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
              <div className="h-4 w-20 bg-zinc-200 rounded mb-2 animate-pulse dark:bg-zinc-800"></div>
              <div className="h-8 w-16 bg-zinc-200 rounded animate-pulse dark:bg-zinc-800"></div>
            </div>
            <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
              <div className="h-4 w-20 bg-zinc-200 rounded mb-2 animate-pulse dark:bg-zinc-800"></div>
              <div className="h-8 w-16 bg-zinc-200 rounded animate-pulse dark:bg-zinc-800"></div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4">
        <h1 className="text-2xl font-bold mb-4 text-zinc-900 dark:text-zinc-100">{t('data.title')}</h1>
        <div className="flex items-center justify-center py-12">
          <p className="text-red-500">{t('data.loadError', { message: error.message })}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="relative min-h-screen bg-zinc-50 pb-24 dark:bg-black">
      <div className="sticky top-0 z-10 border-b bg-white/80 p-4 backdrop-blur-md dark:border-zinc-800 dark:bg-black/80 z-50">
        <h1 className=" text-2xl font-bold tracking-tight text-zinc-900 dark:text-zinc-100">{t('data.title')}</h1>
      </div>

      <div className="p-4 space-y-4">
        {/* Exercise Selector */}
        <div className="relative">
          <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
            {t('data.exercise')}
          </label>
          <div className="relative">
            <button
              onClick={() => setIsDropdownOpen(!isDropdownOpen)}
              className="w-full flex items-center justify-between rounded-xl bg-white text-zinc-900 dark:text-zinc-100 dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 px-4 py-3 text-left font-medium shadow-sm hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors"
            >
              <span>
                {availableExercises.length === 0
                  ? t('data.noExercises')
                  : selectedExercise || t('data.selectExercise')}
              </span>
              <ChevronDown
                className={`h-5 w-5 text-zinc-400 transition-transform ${isDropdownOpen ? 'rotate-180' : ''
                  }`}
              />
            </button>
            {isDropdownOpen && (
              <>
                <div
                  className="fixed inset-0 z-10"
                  onClick={() => setIsDropdownOpen(false)}
                />
                <div className="absolute z-20 w-full mt-1 rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-lg max-h-60 overflow-auto">
                  {availableExercises.length === 0 ? (
                    <div className="px-4 py-3 text-sm text-zinc-500 dark:text-zinc-400">
                      {t('data.noExercises')}
                    </div>
                  ) : availableExercises.map((exercise) => (
                    <button
                      key={exercise}
                      onClick={() => {
                        setSelectedExercise(exercise);
                        setIsDropdownOpen(false);
                      }}
                      className={`w-full px-4 py-3 text-left text-zinc-900 dark:text-zinc-100 hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors ${selectedExercise === exercise
                        ? 'bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400 font-medium'
                        : ''
                        }`}
                    >
                      {exercise}
                    </button>
                  ))}
                </div>
              </>
            )}
          </div>
        </div>

        {/* View Type Tabs */}
        <div>
          <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
            {t('data.view')}
          </label>
          <div className="flex gap-2">
            <button
              onClick={() => setViewType('chart')}
              className={`flex-1 rounded-xl px-4 py-3 font-medium transition-colors ${viewType === 'chart'
                ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'
                : 'bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800'
                }`}
            >
              {t('data.chart')}
            </button>
            <button
              onClick={() => setViewType('history')}
              className={`flex-1 rounded-xl px-4 py-3 font-medium transition-colors ${viewType === 'history'
                ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'
                : 'bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800'
                }`}
            >
              {t('data.history')}
            </button>
          </div>
        </div>

        {/* Metric Selector - Only show in chart view */}
        {viewType === 'chart' && (
          <div>
            <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
              {t('data.metric')}
            </label>
            <div className="flex gap-2">
              {(Object.keys(METRIC_LABELS) as MetricType[]).map((metric) => (
                <button
                  key={metric}
                  onClick={() => setSelectedMetric(metric)}
                  className={`flex-1 rounded-xl px-4 py-3 font-medium transition-colors ${selectedMetric === metric
                    ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'
                    : 'bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 text-zinc-700 dark:text-zinc-300 hover:bg-zinc-50 dark:hover:bg-zinc-800'
                    }`}
                >
                  {METRIC_LABELS[metric]}
                </button>
              ))}
            </div>
          </div>
        )}

        {/* Chart or History Table */}
        {viewType === 'chart' ? (
          <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
            {chartData.length === 0 ? (
              <div className="flex items-center justify-center py-12">
                <p className="text-zinc-500 dark:text-zinc-400">{t('data.noChartData')}</p>
              </div>
            ) : (
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={chartData} margin={{ top: 5, right: 10, left: 0, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#e4e4e7" className="dark:stroke-zinc-800" />
                  <XAxis
                    dataKey="formattedDate"
                    stroke="#71717a"
                    className="text-xs"
                    tick={{ fill: '#71717a', fontSize: 12 }}
                  />
                  <YAxis
                    domain={['auto', 'auto']}
                    stroke="#71717a"
                    className="text-xs"
                    tick={{ fill: '#71717a', fontSize: 12 }}
                  />
                  <Tooltip
                    contentStyle={{
                      backgroundColor: 'white',
                      border: '1px solid #e4e4e7',
                      borderRadius: '8px',
                      padding: '8px 12px',
                    }}
                    labelStyle={{ color: '#18181b', fontWeight: 600 }}
                    formatter={(value: number | undefined) => {
                      if (value === undefined) return '';
                      if (selectedMetric === 'totalVolume') {
                        return `${value.toLocaleString()} kg`;
                      }
                      if (selectedMetric === 'maxWeight' || selectedMetric === 'maxVolume') {
                        return `${value} kg`;
                      }
                      return value;
                    }}
                  />
                  <Line
                    type="monotone"
                    dataKey="value"
                    stroke="#2563eb"
                    strokeWidth={2}
                    dot={{ fill: '#2563eb', r: 4 }}
                    activeDot={{ r: 6 }}
                  />
                </LineChart>
              </ResponsiveContainer>
            )}
          </div>
        ) : (
          <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
            {isHistoryLoading ? (
              <div className="flex items-center justify-center py-12">
                <p className="text-zinc-500 dark:text-zinc-400">이력을 불러오는 중...</p>
              </div>
            ) : exerciseHistory.length === 0 ? (
              <div className="flex items-center justify-center py-12">
                <p className="text-zinc-500 dark:text-zinc-400">{t('data.noHistoryData')}</p>
              </div>
            ) : (
              <div className="overflow-x-auto -mx-4 px-0">
                <table className="w-full border-collapse">
                  <thead>
                    <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
                      <th className="text-center py-3 px-3 text-sm font-semibold text-zinc-900 dark:text-zinc-100 sticky left-0 bg-white dark:bg-zinc-900 z-10">
                        {t('data.set')}
                      </th>
                      {exerciseHistory.slice().reverse().map((workout, index) => (
                        <th
                          key={workout.workoutId}
                          className="text-center py-3 px-1 text-sm font-semibold text-zinc-900 dark:text-zinc-100 min-w-[100px] bg-zinc-50 dark:bg-zinc-800/50"
                        >
                          <div className="font-bold">{t('data.timesAgo', { n: exerciseHistory.length - index })}</div>
                          <div className="text-xs text-zinc-500 dark:text-zinc-400 mt-1 font-normal">
                            {format(parseISO(workout.workoutDate), 'MM/dd')}
                          </div>
                        </th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {(() => {
                      // Find max number of sets across all workouts
                      const maxSets = Math.max(...exerciseHistory.map(w => w.sets.length));
                      const rows = [];

                      // Add set rows
                      for (let setIndex = 0; setIndex < maxSets; setIndex++) {
                        rows.push(
                          <tr
                            key={setIndex}
                            className="border-b border-zinc-200 dark:border-zinc-800 hover:bg-zinc-50 dark:hover:bg-zinc-800/30 transition-colors"
                          >
                            <td className="py-3 px-3 text-center text-sm font-semibold text-zinc-700 dark:text-zinc-300 sticky left-0 bg-white dark:bg-zinc-900 z-10 border-r border-zinc-200 dark:border-zinc-800">
                              {setIndex + 1}
                            </td>
                            {exerciseHistory.slice().reverse().map((workout) => {
                              const set = workout.sets[setIndex];
                              return (
                                <td
                                  key={workout.workoutId}
                                  className="py-3 px-1 text-center text-sm"
                                >
                                  {set ? (
                                    <div className="flex flex-col items-center gap-0.5">
                                      <div className="font-bold text-zinc-900 dark:text-zinc-100">
                                        {set.weight}kg
                                      </div>
                                      <div className="text-xs text-zinc-500 dark:text-zinc-400">
                                        × {set.reps}회
                                      </div>
                                    </div>
                                  ) : (
                                    <span className="text-zinc-400 dark:text-zinc-600">-</span>
                                  )}
                                </td>
                              );
                            })}
                          </tr>
                        );
                      }

                      // Add total volume row
                      rows.push(
                        <tr
                          key="total"
                          className="border-t-2 border-zinc-300 dark:border-zinc-700 bg-zinc-50 dark:bg-zinc-800/50"
                        >
                          <td className="py-3 px-3 text-center text-sm font-bold text-zinc-900 dark:text-zinc-100 sticky left-0 bg-zinc-50 dark:bg-zinc-800 z-10 border-r border-zinc-200 dark:border-zinc-800">
                            {t('data.totalKilos')}
                          </td>
                          {exerciseHistory.slice().reverse().map((workout) => {
                            // Calculate total volume for this workout
                            const totalVolume = workout.sets.reduce((sum, set) => {
                              return sum + (set.weight * set.reps);
                            }, 0);
                            return (
                              <td
                                key={workout.workoutId}
                                className="py-3 px-1 text-center text-sm font-bold text-zinc-900 dark:text-zinc-100"
                              >
                                {totalVolume.toLocaleString()}kg
                              </td>
                            );
                          })}
                        </tr>
                      );

                      return rows;
                    })()}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}

        {/* Summary Stats - Only show in chart view */}
        {viewType === 'chart' && (
          <div className="grid grid-cols-2 gap-3">
            {/* Personal Best Card */}
            <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
              <p className="text-sm font-medium text-zinc-500 dark:text-zinc-400 mb-1">
                {t('data.personalBest')}
              </p>
              <p className="text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                {summaryStats.personalBest} <span className="text-base font-normal text-zinc-500">kg</span>
              </p>
            </div>

            {/* Total Records Card */}
            <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm">
              <p className="text-sm font-medium text-zinc-500 dark:text-zinc-400 mb-1">
                {t('data.totalRecords')}
              </p>
              <p className="text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                {summaryStats.totalRecords} <span className="text-base font-normal text-zinc-500">{t('data.days')}</span>
              </p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}



===== FILE: app\(routes)\profile\page.tsx =====
'use client';

import { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { useProfileStore } from '@/stores';
import { Edit2, Save, X, Settings } from 'lucide-react';
import { WeightChart, SettingsModal } from '@/components';

export default function ProfilePage() {
  const { t } = useTranslation();
  const { profile, weightRecords, isLoading, isSaving, isProfileLoaded, isWeightRecordsLoaded, fetchProfile, updateProfile, fetchWeightRecords, addWeightRecord } = useProfileStore();
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    age: '',
    gender: '' as 'male' | 'female' | 'other' | '',
    height: '',
  });
  const [weightInput, setWeightInput] = useState('');
  const [isAddingWeight, setIsAddingWeight] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  useEffect(() => {
    // Only fetch if not already loaded
    if (!isProfileLoaded) {
      fetchProfile();
    }
    if (!isWeightRecordsLoaded) {
      fetchWeightRecords();
    }
  }, [isProfileLoaded, isWeightRecordsLoaded, fetchProfile, fetchWeightRecords]);

  useEffect(() => {
    if (profile) {
      setFormData({
        name: profile.name || '',
        age: profile.age?.toString() || '',
        gender: profile.gender || '',
        height: profile.height?.toString() || '',
      });
    }
  }, [profile]);

  const handleSave = async () => {
    await updateProfile({
      name: formData.name || null,
      age: formData.age ? parseInt(formData.age) : null,
      gender: formData.gender || null,
      height: formData.height ? parseFloat(formData.height) : null,
    });
    setIsEditing(false);
  };

  const handleCancel = () => {
    if (profile) {
      setFormData({
        name: profile.name || '',
        age: profile.age?.toString() || '',
        gender: profile.gender || '',
        height: profile.height?.toString() || '',
      });
    }
    setIsEditing(false);
  };

  const handleAddWeight = async () => {
    const weight = parseFloat(weightInput);
    if (isNaN(weight) || weight <= 0) {
      alert(t('profile.enterValidWeight'));
      return;
    }
    await addWeightRecord(weight);
    setWeightInput('');
    setIsAddingWeight(false);
  };

  if (isLoading) {
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4 text-zinc-900 dark:text-zinc-100">{t('profile.title')}</h1>
        <div className="space-y-4">
          <div className="h-20 bg-zinc-100 dark:bg-zinc-900 rounded-2xl animate-pulse" />
          <div className="h-20 bg-zinc-100 dark:bg-zinc-900 rounded-2xl animate-pulse" />
        </div>
      </div>
    );
  }

  return (
    <div className="p-4 pb-24">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-bold text-zinc-900 dark:text-zinc-100">{t('profile.title')}</h1>
        <button
          onClick={() => setIsSettingsOpen(true)}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <Settings className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
      </div>

      {/* Profile Information Card */}
      <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm mb-4">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold text-zinc-900 dark:text-zinc-100">{t('profile.basicInfo')}</h2>
          {!isEditing ? (
            <button
              onClick={() => setIsEditing(true)}
              className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
            >
              <Edit2 className="h-4 w-4 text-zinc-600 dark:text-zinc-400" />
            </button>
          ) : (
            <div className="flex gap-2">
              <button
                onClick={handleSave}
                disabled={isSaving}
                className="p-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 transition-colors disabled:opacity-50"
              >
                <Save className="h-4 w-4" />
              </button>
              <button
                onClick={handleCancel}
                className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
              >
                <X className="h-4 w-4 text-zinc-600 dark:text-zinc-400" />
              </button>
            </div>
          )}
        </div>

        <div className="space-y-4">
          {/* Name */}
          <div>
            <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
              {t('profile.name')}
            </label>
            {isEditing ? (
              <input
                type="text"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="w-full rounded-xl bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder={t('profile.namePlaceholder')}
              />
            ) : (
              <div className="text-zinc-900 dark:text-zinc-100">
                {profile?.name || t('profile.notSet')}
              </div>
            )}
          </div>

          {/* Age */}
          <div>
            <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
              {t('profile.age')}
            </label>
            {isEditing ? (
              <input
                type="number"
                value={formData.age}
                onChange={(e) => setFormData({ ...formData, age: e.target.value })}
                className="w-full rounded-xl bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder={t('profile.agePlaceholder')}
                min="0"
                max="150"
              />
            ) : (
              <div className="text-zinc-900 dark:text-zinc-100">
                {profile?.age ? `${profile.age} ${t('profile.years')}` : t('profile.notSet')}
              </div>
            )}
          </div>

          {/* Gender */}
          <div>
            <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
              {t('profile.gender')}
            </label>
            {isEditing ? (
              <div className="flex gap-2">
                {(['male', 'female', 'other'] as const).map((gender) => (
                  <button
                    key={gender}
                    onClick={() => setFormData({ ...formData, gender })}
                    className={`flex-1 rounded-xl px-4 py-3 font-medium transition-colors ${
                      formData.gender === gender
                        ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/20'
                        : 'bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 text-zinc-700 dark:text-zinc-300 hover:bg-zinc-100 dark:hover:bg-zinc-700'
                    }`}
                  >
                    {t(`profile.${gender}`)}
                  </button>
                ))}
              </div>
            ) : (
              <div className="text-zinc-900 dark:text-zinc-100">
                {profile?.gender ? t(`profile.${profile.gender}`) : t('profile.notSet')}
              </div>
            )}
          </div>

          {/* Height */}
          <div>
            <label className="block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2">
              {t('profile.height')}
            </label>
            {isEditing ? (
              <input
                type="number"
                value={formData.height}
                onChange={(e) => setFormData({ ...formData, height: e.target.value })}
                className="w-full rounded-xl bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder={t('profile.heightPlaceholder')}
                min="0"
                max="300"
                step="0.1"
              />
            ) : (
              <div className="text-zinc-900 dark:text-zinc-100">
                {profile?.height ? `${profile.height}cm` : t('profile.notSet')}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Weight Tracking Card */}
      <div className="rounded-2xl bg-white dark:bg-zinc-900 p-4 shadow-sm mb-4">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold text-zinc-900 dark:text-zinc-100">{t('profile.weightRecords')}</h2>
          {!isAddingWeight ? (
            <button
              onClick={() => setIsAddingWeight(true)}
              className="px-4 py-2 rounded-xl bg-blue-600 text-white text-sm font-medium hover:bg-blue-700 transition-colors"
            >
              {t('profile.add')}
            </button>
          ) : (
            <div className="flex gap-2">
              <button
                onClick={handleAddWeight}
                disabled={isSaving}
                className="px-4 py-2 rounded-xl bg-blue-600 text-white text-sm font-medium hover:bg-blue-700 transition-colors disabled:opacity-50"
              >
                {t('profile.save')}
              </button>
              <button
                onClick={() => {
                  setIsAddingWeight(false);
                  setWeightInput('');
                }}
                className="px-4 py-2 rounded-xl bg-zinc-100 dark:bg-zinc-800 text-zinc-700 dark:text-zinc-300 text-sm font-medium hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors"
              >
                {t('common.cancel')}
              </button>
            </div>
          )}
        </div>

        {isAddingWeight && (
          <div className="mb-4">
            <input
              type="number"
              value={weightInput}
              onChange={(e) => setWeightInput(e.target.value)}
              className="w-full rounded-xl bg-zinc-50 dark:bg-zinc-800 border border-zinc-200 dark:border-zinc-700 px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder={t('profile.weightPlaceholder')}
              min="0"
              max="500"
              step="0.1"
              autoFocus
            />
          </div>
        )}

        {/* Current Weight Display */}
        {weightRecords.length > 0 && (
          <div className="mb-4 p-3 rounded-xl bg-blue-50 dark:bg-blue-900/20">
            <div className="text-sm text-zinc-600 dark:text-zinc-400 mb-1">{t('profile.currentWeight')}</div>
            <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">
              {weightRecords[0].weight} <span className="text-base font-normal">kg</span>
            </div>
          </div>
        )}

        {/* Weight Chart */}
        <WeightChart weightRecords={weightRecords} />
      </div>

      <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />
    </div>
  );
}



===== FILE: app\(routes)\workout\page.tsx =====
"use client";

import { useState, useEffect } from "react";
import { useTranslation } from "react-i18next";
import { Play } from "lucide-react";
import { WorkoutWithDetails } from "@/types/workout";
import { useWorkoutHistoryStore } from "@/stores";
import { formatDate, formatDuration } from "@/utils";
import { deleteWorkout } from "@/services";
import {
  WorkoutHistoryCard,
  ActiveSessionDrawer,
  WorkoutDetailDrawer,
  type ExerciseItem,
} from "@/components";

export default function WorkoutPage() {
  const { t } = useTranslation();
  const [isWorkoutActive, setIsWorkoutActive] = useState(false);
  const { historyWorkouts, isLoading, isLoaded, refreshWorkoutHistory, fetchWorkoutHistory } = useWorkoutHistoryStore();

  useEffect(() => {
    // Only fetch if not already loaded
    if (!isLoaded) {
      fetchWorkoutHistory();
    }
  }, [isLoaded, fetchWorkoutHistory]);

  // Listen for workout saved event to refresh history
  useEffect(() => {
    const handleWorkoutSaved = () => {
      refreshWorkoutHistory();
    };

    if (typeof window !== 'undefined') {
      window.addEventListener('workoutSaved', handleWorkoutSaved);
      return () => {
        window.removeEventListener('workoutSaved', handleWorkoutSaved);
      };
    }
  }, [refreshWorkoutHistory]);
  const [selectedWorkout, setSelectedWorkout] = useState<WorkoutWithDetails | null>(null);

  // Active session state props
  const [activeSessionInitialData, setActiveSessionInitialData] = useState<ExerciseItem[] | undefined>(undefined);
  const [activeSessionInitialName, setActiveSessionInitialName] = useState<string | undefined>(undefined);

  const handleDelete = async (id: string) => {
    try {
      await deleteWorkout(id);

      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('workoutDeleted'));
      }

      await refreshWorkoutHistory();
    } catch (error) {
      console.error("Error deleting workout:", error);
      alert(t('workout.deleteWorkoutFailed'));
    }
  };

  const handleStartRoutine = (workout: WorkoutWithDetails) => {
    const initialData: ExerciseItem[] = workout.exercises.map((ex) => ({
      id: crypto.randomUUID(),
      name: ex.name,
      sets: ex.sets.map((set) => ({
        id: crypto.randomUUID(),
        weight: set.weight,
        reps: set.reps,
        isCompleted: false,
      })),
    }));

    setActiveSessionInitialData(initialData);
    setActiveSessionInitialName(workout.name); // Set name from history
    setSelectedWorkout(null);
    setIsWorkoutActive(true);
  };

  return (
    <div className="relative min-h-screen bg-zinc-50 pb-24 dark:bg-black">
      {/* Sticky Start Button Header */}
      <div className="sticky top-0 z-10 border-b bg-white/80 p-4 backdrop-blur-md dark:border-zinc-800 dark:bg-black/80 z-50">
        <h1 className="mb-4 text-2xl font-bold tracking-tight text-zinc-900 dark:text-zinc-100">{t('workout.title')}</h1>
        <button
          onClick={() => {
            setActiveSessionInitialData(undefined);
            setActiveSessionInitialName(undefined); // Let drawer handle default date name
            setIsWorkoutActive(true);
          }}
          className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white shadow-lg shadow-blue-500/20 transition-transform hover:scale-[1.02] active:scale-[0.98]"
        >
          <Play className="h-5 w-5 fill-current" />
          {t('workout.startEmpty')}
        </button>
      </div>

      {/* History Grid */}
      <div className="p-4">
        <h2 className="mb-3 text-sm font-medium text-zinc-500 uppercase tracking-wider">{t('workout.recentRoutines')}</h2>

        {isLoading ? (
          <div className="grid grid-cols-2 gap-3">
            {[1, 2, 3, 4].map((i) => (
              <div key={i} className="flex flex-col gap-3 rounded-2xl bg-white p-4 shadow-sm h-32 animate-pulse dark:bg-zinc-900">
                <div className="h-4 w-12 bg-zinc-200 rounded dark:bg-zinc-800"></div>
                <div className="h-6 w-24 bg-zinc-200 rounded dark:bg-zinc-800"></div>
                <div className="mt-auto flex flex-col gap-2">
                  <div className="h-3 w-16 bg-zinc-200 rounded dark:bg-zinc-800"></div>
                  <div className="h-3 w-16 bg-zinc-200 rounded dark:bg-zinc-800"></div>
                </div>
              </div>
            ))}
          </div>
        ) : historyWorkouts.length === 0 ? (
          <div className="flex flex-col items-center justify-center py-12 text-zinc-500">
            <p>{t('workout.noHistory')}</p>
          </div>
        ) : (
          <div className="grid grid-cols-2 gap-3">
            {historyWorkouts.map((workout) => (
              <WorkoutHistoryCard
                key={workout.id}
                id={workout.id}
                date={formatDate(workout.start_time)}
                duration={formatDuration(workout.start_time, workout.end_time)}
                totalWeight={workout.total_weight}
                workoutName={workout.name}
                onDelete={handleDelete}
                onClick={() => setSelectedWorkout(workout)}
              />
            ))}
          </div>
        )}
      </div>

      {/* Active Session Drawer */}
      <ActiveSessionDrawer
        isOpen={isWorkoutActive}
        onClose={() => setIsWorkoutActive(false)}
        initialData={activeSessionInitialData}
        initialWorkoutName={activeSessionInitialName}
      />

      {/* Workout Detail Drawer */}
      <WorkoutDetailDrawer
        isOpen={!!selectedWorkout}
        workout={selectedWorkout}
        onClose={() => setSelectedWorkout(null)}
        onStartRoutine={handleStartRoutine}
      />
    </div>
  );
}



===== FILE: src\components\index.ts =====
// Providers
export { AuthProvider, ThemeProvider, I18nProvider } from './providers';

// Common components
export { BottomNavigation, DeleteConfirmModal, ErrorBoundary } from './common';

// Features
export * from './features';



===== FILE: src\components\common\BottomNavigation.tsx =====
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { useTranslation } from "react-i18next";
import { Home, Dumbbell, BarChart2, User } from "lucide-react";

const NAV_KEYS = [
  { key: "nav.home", href: "/", icon: Home },
  { key: "nav.workout", href: "/workout", icon: Dumbbell },
  { key: "nav.data", href: "/data", icon: BarChart2 },
  { key: "nav.profile", href: "/profile", icon: User },
] as const;

export function BottomNavigation() {
  const pathname = usePathname();
  const { t } = useTranslation();

  return (
    <nav className="fixed bottom-0 left-0 right-0 z-50 border-t bg-white pb-safe pt-2 dark:bg-zinc-950 dark:border-zinc-800">
      <div className="mx-auto flex h-16 max-w-md items-center justify-around px-2">
        {NAV_KEYS.map(({ key, href, icon: Icon }) => {
          const isActive = pathname === href;
          const name = t(key);
          return (
            <Link
              key={href}
              href={href}
              className={`flex flex-col items-center justify-center gap-1 pb-4 transition-colors ${isActive
                ? "text-blue-600 dark:text-blue-500"
                : "text-zinc-500 hover:text-zinc-900 dark:text-zinc-400 dark:hover:text-zinc-100"
                }`}
            >
              <Icon className={`h-6 w-6 ${isActive ? "fill-current/20" : ""}`} />
              <span className="text-[10px] font-medium">{name}</span>
            </Link>
          );
        })}
      </div>
    </nav>
  );
}



===== FILE: src\components\common\ErrorBoundary.tsx =====
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw, Home } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // 에러 로깅 (나중에 Sentry로 교체 가능)
    console.error('ErrorBoundary caught an error:', error, errorInfo);

    this.setState({
      error,
      errorInfo,
    });

    // 커스텀 에러 핸들러 호출
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleGoHome = () => {
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      // 커스텀 fallback UI가 제공된 경우
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // 기본 에러 UI
      return (
        <div className="min-h-screen bg-zinc-50 dark:bg-black flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white dark:bg-zinc-900 rounded-2xl shadow-lg p-6 space-y-4">
            {/* 에러 아이콘 */}
            <div className="flex justify-center">
              <div className="rounded-full bg-red-100 dark:bg-red-900/20 p-3">
                <AlertTriangle className="h-8 w-8 text-red-600 dark:text-red-400" />
              </div>
            </div>

            {/* 에러 메시지 */}
            <div className="text-center space-y-2">
              <h1 className="text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                문제가 발생했습니다
              </h1>
              <p className="text-zinc-600 dark:text-zinc-400">
                예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 홈으로 돌아가주세요.
              </p>
            </div>

            {/* 에러 상세 정보 (개발 환경에서만) */}
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <div className="mt-4 p-4 bg-zinc-100 dark:bg-zinc-800 rounded-lg">
                <details className="space-y-2">
                  <summary className="cursor-pointer text-sm font-medium text-zinc-700 dark:text-zinc-300">
                    에러 상세 정보 (개발 모드)
                  </summary>
                  <div className="mt-2 text-xs font-mono text-red-600 dark:text-red-400 break-all">
                    <div className="font-semibold mb-1">에러 메시지:</div>
                    <div className="mb-3">{this.state.error.message}</div>
                    {this.state.error.stack && (
                      <>
                        <div className="font-semibold mb-1">스택 트레이스:</div>
                        <pre className="whitespace-pre-wrap text-xs">
                          {this.state.error.stack}
                        </pre>
                      </>
                    )}
                    {this.state.errorInfo && (
                      <>
                        <div className="font-semibold mb-1 mt-3">컴포넌트 스택:</div>
                        <pre className="whitespace-pre-wrap text-xs">
                          {this.state.errorInfo.componentStack}
                        </pre>
                      </>
                    )}
                  </div>
                </details>
              </div>
            )}

            {/* 액션 버튼 */}
            <div className="flex flex-col gap-2 pt-4">
              <button
                onClick={this.handleReset}
                className="flex items-center justify-center gap-2 w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl font-medium transition-colors"
              >
                <RefreshCw className="h-5 w-5" />
                다시 시도
              </button>
              <button
                onClick={this.handleGoHome}
                className="flex items-center justify-center gap-2 w-full px-4 py-3 bg-zinc-200 dark:bg-zinc-800 hover:bg-zinc-300 dark:hover:bg-zinc-700 text-zinc-900 dark:text-zinc-100 rounded-xl font-medium transition-colors"
              >
                <Home className="h-5 w-5" />
                홈으로 이동
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}



===== FILE: src\components\common\index.ts =====
export { BottomNavigation } from './BottomNavigation';
export { DeleteConfirmModal } from './modals';
export { ErrorBoundary } from './ErrorBoundary';



===== FILE: src\components\common\modals\DeleteConfirmModal.tsx =====
"use client";

import { motion, AnimatePresence } from "framer-motion";

interface DeleteConfirmModalProps {
  isOpen: boolean;
  title?: string;
  message: string;
  subMessage?: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel: () => void;
}

export function DeleteConfirmModal({
  isOpen,
  title = "Delete?",
  message,
  subMessage,
  confirmText = "Delete",
  cancelText = "Cancel",
  onConfirm,
  onCancel,
}: DeleteConfirmModalProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onCancel}
          />

          {/* Modal Content */}
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            className="relative w-full max-w-sm overflow-hidden rounded-3xl bg-white p-6 shadow-2xl dark:bg-zinc-900"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex flex-col items-center text-center">
              <h2 className="mb-2 text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                {title}
              </h2>
              <p className="mb-6 text-sm text-zinc-500 dark:text-zinc-400">
                {message}
                {subMessage && (
                  <>
                    <br />
                    <span className="text-xs">{subMessage}</span>
                  </>
                )}
              </p>

              <div className="flex w-full flex-col gap-3">
                <button
                  onClick={onConfirm}
                  className="flex w-full items-center justify-center gap-2 rounded-xl bg-red-600 py-3.5 font-bold text-white transition-colors hover:bg-red-700"
                >
                  {confirmText}
                </button>
                <button
                  onClick={onCancel}
                  className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-300"
                >
                  {cancelText}
                </button>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}



===== FILE: src\components\common\modals\index.ts =====
export { DeleteConfirmModal } from './DeleteConfirmModal';



===== FILE: src\components\features\index.ts =====
// Home
export {
  WeeklyGoalProgress,
  WeeklyGoalModal,
  SplitConfig,
  SplitCountModal,
  SplitOrderModal,
  TodayWorkoutCard,
  WeeklySchedule,
} from './home';

// Workout
export {
  ActiveSessionDrawer,
  ExerciseCard,
  AddExerciseModal,
  RestTimerModal,
  WorkoutSummaryModal,
  WorkoutHistoryCard,
  WorkoutDetailDrawer,
  WorkoutDetailModal,
  WorkoutDetailView,
} from './workout';
export type { ActiveSessionDrawerProps, ExerciseItem, ExerciseSet } from './workout';

// Profile
export { SettingsModal, WeightChart } from './profile';



===== FILE: src\components\features\data\index.ts =====
// Data feature components (charts, etc.)
// Add exports here as needed



===== FILE: src\components\features\home\index.ts =====
export { WeeklyGoalProgress } from './WeeklyGoalProgress';
export { WeeklyGoalModal } from './WeeklyGoalModal';
export { SplitConfig } from './SplitConfig';
export { SplitCountModal } from './SplitCountModal';
export { SplitOrderModal } from './SplitOrderModal';
export { TodayWorkoutCard } from './TodayWorkoutCard';
export { WeeklySchedule } from './weekly-schedule';



===== FILE: src\components\features\home\SplitConfig.tsx =====
"use client";

import { useState, useEffect } from "react";
import { SplitCountModal } from "./SplitCountModal";
import { SplitOrderModal } from "./SplitOrderModal";
import { useUserStore } from "@/stores";
import { saveSplitCount as saveSplitCountService, saveSplitOrder as saveSplitOrderService } from "@/services";
import { t } from "i18next";

interface SplitConfigData {
  split_count: number;
  split_order: string[];
}

interface SplitConfigProps {
  splitConfig: SplitConfigData | null;
  workoutNames: string[];
  onDataChange?: () => void;
}

export function SplitConfig({ splitConfig: initialSplitConfig, workoutNames: initialWorkoutNames, onDataChange }: SplitConfigProps) {
  const [splitConfig, setSplitConfig] = useState<SplitConfigData | null>(initialSplitConfig);
  const [workoutNames, setWorkoutNames] = useState<string[]>(initialWorkoutNames);
  const [isCountModalOpen, setIsCountModalOpen] = useState(false);
  const [isOrderModalOpen, setIsOrderModalOpen] = useState(false);

  useEffect(() => {
    setSplitConfig(initialSplitConfig);
    setWorkoutNames(initialWorkoutNames);
  }, [initialSplitConfig, initialWorkoutNames]);

  const saveSplitCount = async (count: number) => {
    try {
      const userId = await useUserStore.getState().getUserId();
      await saveSplitCountService(userId, count);

      setSplitConfig({ split_count: count, split_order: [] });
      setIsCountModalOpen(false);
      setIsOrderModalOpen(true);

      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('homeDataChanged'));
      }
    } catch (error) {
      console.error("Error saving split count:", error);
      alert(t('home.split.saveCountError'));
      throw error;
    }
  };

  const saveSplitOrder = async (order: string[]) => {
    try {
      const userId = await useUserStore.getState().getUserId();
      const splitCount = await saveSplitOrderService(userId, order);

      setSplitConfig({ split_count: splitCount, split_order: order });
      setIsOrderModalOpen(false);

      if (onDataChange) {
        onDataChange();
      }

      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('homeDataChanged'));
      }
    } catch (error) {
      console.error("Error saving split order:", error);
      alert("분할 순서 저장에 실패했습니다");
      throw error;
    }
  };

  useEffect(() => {
    // If no config exists, show count modal on mount
    if (!splitConfig && !isCountModalOpen && !isOrderModalOpen) {
      setIsCountModalOpen(true);
    }
  }, [splitConfig, isCountModalOpen, isOrderModalOpen]);

  const handleEdit = () => {
    if (workoutNames.length === 0) {
      alert("먼저 운동 프로그램을 저장해주세요.");
      return;
    }
    // Show order modal to edit the split order
    setIsOrderModalOpen(true);
  };

  const handleChangeSplitCount = () => {
    setIsCountModalOpen(true);
  };

  if (!splitConfig) {
    return (
      <>
        <div
          onClick={() => setIsCountModalOpen(true)}
          className="mb-4 cursor-pointer rounded-2xl bg-zinc-100 p-4 dark:bg-zinc-900"
        >
          <p className="text-sm text-zinc-500 dark:text-zinc-400">
            {t('home.split.setPrompt')}
          </p>
        </div>
        <SplitCountModal
          isOpen={isCountModalOpen}
          currentCount={null}
          onSave={saveSplitCount}
          onClose={() => setIsCountModalOpen(false)}
        />
        <SplitOrderModal
          isOpen={isOrderModalOpen}
          splitCount={0}
          workoutNames={workoutNames}
          currentOrder={null}
          onSave={saveSplitOrder}
          onClose={() => setIsOrderModalOpen(false)}
        />
      </>
    );
  }

  return (
    <>
      <div className="mb-4 rounded-2xl bg-zinc-100 p-4 dark:bg-zinc-900">
        <div className="mb-2 flex items-center justify-between">
          <p className="text-sm font-medium text-zinc-900 dark:text-zinc-100">
            {t('home.split.splitCount', { count: splitConfig.split_count })}
          </p>
          <button
            onClick={handleChangeSplitCount}
            className="text-xs text-blue-600 dark:text-blue-400 hover:underline"
          >
            {t('home.split.changeSplit')}
          </button>
        </div>
        <div
          onClick={handleEdit}
          className="cursor-pointer  grid grid-cols-4 gap-2 space-y-1 transition-colors hover:opacity-80"
        >
          {splitConfig.split_order.map((workout, index) => (
            <div
              key={index}
              className="flex items-center gap-2 text-sm text-zinc-600 dark:text-zinc-400"
            >
              <span className="flex items-center justify-center w-5 h-5 rounded-full bg-blue-600 text-white text-xs font-bold">
                {index + 1}
              </span>
              <span>
                {workout.length > 5 ? workout.slice(0, 5) + ".." : workout}
              </span>
            </div>
          ))}
        </div>
      </div>
      <SplitCountModal
        isOpen={isCountModalOpen}
        currentCount={splitConfig.split_count}
        onSave={saveSplitCount}
        onClose={() => setIsCountModalOpen(false)}
      />
      <SplitOrderModal
        isOpen={isOrderModalOpen}
        splitCount={splitConfig.split_count}
        workoutNames={workoutNames}
        currentOrder={splitConfig.split_order}
        onSave={saveSplitOrder}
        onClose={() => setIsOrderModalOpen(false)}
      />
    </>
  );
}



===== FILE: src\components\features\home\SplitCountModal.tsx =====
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { useState, useEffect } from "react";
import { useTranslation } from "react-i18next";
import { X } from "lucide-react";

interface SplitCountModalProps {
  isOpen: boolean;
  currentCount: number | null;
  onSave: (count: number) => void;
  onClose: () => void;
}

export function SplitCountModal({
  isOpen,
  currentCount,
  onSave,
  onClose,
}: SplitCountModalProps) {
  const { t } = useTranslation();
  const [selectedCount, setSelectedCount] = useState<number>(currentCount || 3);
  const [isSaving, setIsSaving] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setSelectedCount(currentCount || 3);
      setIsSaving(false);
    }
  }, [isOpen, currentCount]);

  const handleSave = async () => {
    setIsSaving(true);
    try {
      await onSave(selectedCount);
      onClose();
    } catch (error) {
      console.error("Error saving split count:", error);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[80] flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          />

          {/* Modal Content */}
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            className="relative w-full max-w-sm overflow-hidden rounded-3xl bg-white p-6 shadow-2xl dark:bg-zinc-900"
          >
            <button
              onClick={onClose}
              className="absolute right-4 top-4 rounded-full p-1 text-zinc-500 hover:bg-zinc-100 hover:text-zinc-900 dark:hover:bg-zinc-800 dark:hover:text-zinc-100"
            >
              <X className="h-5 w-5" />
            </button>

            <div className="flex flex-col">
              <h2 className="mb-2 text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                {t('modals.splitCountTitle')}
              </h2>
              <p className="mb-6 text-sm text-zinc-500 dark:text-zinc-400">
                {t('modals.splitCountDesc')}
              </p>

              {/* Select Input */}
              <div className="mb-6">
                <label htmlFor="splitCount" className="sr-only">
                  {t('modals.splitCountLabel')}
                </label>
                <select
                  id="splitCount"
                  value={selectedCount}
                  onChange={(e) => setSelectedCount(Number(e.target.value))}
                  className="w-full rounded-xl border border-zinc-200 bg-zinc-50 px-4 py-3 text-center text-lg font-medium outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100"
                >
                  {Array.from({ length: 7 }, (_, i) => i + 1).map((num) => (
                    <option key={num} value={num}>
                      {t('modals.splitOption', { n: num })}
                    </option>
                  ))}
                </select>
              </div>

              <div className="flex w-full flex-col gap-3">
                <button
                  onClick={handleSave}
                  disabled={isSaving}
                  className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white transition-colors hover:bg-blue-700 disabled:opacity-70 disabled:cursor-not-allowed"
                >
                  {isSaving ? t('modals.saving') : t('modals.next')}
                </button>
                <button
                  onClick={onClose}
                  disabled={isSaving}
                  className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-300 disabled:opacity-50"
                >
                  {t('modals.cancel')}
                </button>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}



===== FILE: src\components\features\home\SplitOrderModal.tsx =====
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { useState, useEffect } from "react";
import { X, ChevronRight } from "lucide-react";

interface SplitOrderModalProps {
  isOpen: boolean;
  splitCount: number;
  workoutNames: string[];
  currentOrder: string[] | null;
  onSave: (order: string[]) => void;
  onClose: () => void;
}

export function SplitOrderModal({
  isOpen,
  splitCount,
  workoutNames,
  currentOrder,
  onSave,
  onClose,
}: SplitOrderModalProps) {
  const [selectedOrder, setSelectedOrder] = useState<string[]>([]);
  const [currentEditingIndex, setCurrentEditingIndex] = useState<number>(0);
  const [isSelectingWorkout, setIsSelectingWorkout] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [selectedWorkoutName, setSelectedWorkoutName] = useState<string | null>(null);

  useEffect(() => {
    if (isOpen) {
      if (currentOrder && currentOrder.length === splitCount) {
        setSelectedOrder(currentOrder);
      } else {
        setSelectedOrder(Array(splitCount).fill(""));
      }
      setCurrentEditingIndex(0);
      setIsSelectingWorkout(false);
      setIsSaving(false);
      setSelectedWorkoutName(null);
    }
  }, [isOpen, splitCount, currentOrder]);

  const handleSelectWorkout = (workoutName: string) => {
    // Show selected state
    setSelectedWorkoutName(workoutName);

    // After 0.5 seconds, save and move to next
    setTimeout(() => {
      const newOrder = [...selectedOrder];
      newOrder[currentEditingIndex] = workoutName;
      setSelectedOrder(newOrder);
      setSelectedWorkoutName(null);

      // Move to next split if available
      const nextIndex = currentEditingIndex + 1;
      if (nextIndex < splitCount) {
        setCurrentEditingIndex(nextIndex);
      } else {
        setIsSelectingWorkout(false);
      }
    }, 500);
  };

  const handleSave = async () => {
    if (selectedOrder.some((name) => !name)) {
      alert("모든 분할에 운동을 선택해주세요.");
      return;
    }
    setIsSaving(true);
    try {
      await onSave(selectedOrder);
      onClose();
    } catch (error) {
      console.error("Error saving split order:", error);
    } finally {
      setIsSaving(false);
    }
  };

  const isComplete = selectedOrder.every((name) => name !== "");

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[80] flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          />

          {/* Modal Content */}
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            className="relative w-full max-w-sm overflow-hidden rounded-3xl bg-white p-6 shadow-2xl dark:bg-zinc-900 max-h-[90vh] flex flex-col"
          >
            <button
              onClick={onClose}
              className="absolute right-4 top-4 rounded-full p-1 text-zinc-500 hover:bg-zinc-100 hover:text-zinc-900 dark:hover:bg-zinc-800 dark:hover:text-zinc-100 z-10"
            >
              <X className="h-5 w-5" />
            </button>

            <div className="flex flex-col flex-1 overflow-hidden">
              <h2 className="mb-2 text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                분할 순서 설정
              </h2>
              <p className="mb-6 text-sm text-zinc-500 dark:text-zinc-400">
                각 분할에 운동 프로그램을 선택하세요
              </p>

              {!isSelectingWorkout ? (
                <>
                  {/* Split Order List */}
                  <div className="flex-1 overflow-y-auto mb-6 space-y-3">
                    {Array.from({ length: splitCount }, (_, i) => i).map((index) => (
                      <div
                        key={index}
                        onClick={() => {
                          setCurrentEditingIndex(index);
                          setIsSelectingWorkout(true);
                        }}
                        className={`flex items-center justify-between p-4 rounded-xl border-2 cursor-pointer transition-colors ${selectedOrder[index]
                            ? "border-blue-500 bg-blue-50 dark:bg-blue-900/20"
                            : "border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-950"
                          }`}
                      >
                        <div className="flex items-center gap-3">
                          <div className="flex items-center justify-center w-8 h-8 rounded-full bg-blue-600 text-white font-bold text-sm">
                            {index + 1}
                          </div>
                          <span className="font-medium text-zinc-900 dark:text-zinc-100">
                            {selectedOrder[index] || "운동 선택"}
                          </span>
                        </div>
                        <ChevronRight className="h-5 w-5 text-zinc-400" />
                      </div>
                    ))}
                  </div>

                  <div className="flex w-full flex-col gap-3">
                    <button
                      onClick={handleSave}
                      disabled={isSaving || !isComplete}
                      className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white transition-colors hover:bg-blue-700 disabled:opacity-70 disabled:cursor-not-allowed"
                    >
                      {isSaving ? "저장 중..." : "확인"}
                    </button>
                    <button
                      onClick={onClose}
                      disabled={isSaving}
                      className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-300 disabled:opacity-50"
                    >
                      취소
                    </button>
                  </div>
                </>
              ) : (
                <>
                  {/* Workout Selection */}
                  <div className="flex-1 overflow-y-auto mb-6">
                    <p className="mb-4 text-sm font-medium text-zinc-700 dark:text-zinc-300">
                      {currentEditingIndex + 1}분할 운동 선택
                    </p>
                    <div className="space-y-2">
                      {workoutNames.length === 0 ? (
                        <p className="text-sm text-zinc-500 dark:text-zinc-400 text-center py-8">
                          저장된 운동 프로그램이 없습니다.
                          <br />
                          먼저 운동을 저장해주세요.
                        </p>
                      ) : (
                        workoutNames.map((name) => (
                          <button
                            key={name}
                            onClick={() => handleSelectWorkout(name)}
                            disabled={selectedWorkoutName !== null}
                            className={`w-full p-4 rounded-xl border-2 text-left transition-all duration-300 ${selectedWorkoutName === name
                                ? "border-blue-600 bg-blue-600 text-white scale-95"
                                : "border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-blue-900/20"
                              } disabled:opacity-50 disabled:cursor-not-allowed`}
                          >
                            <span className={`font-medium ${selectedWorkoutName === name
                                ? "text-white"
                                : "text-zinc-900 dark:text-zinc-100"
                              }`}>
                              {name}
                            </span>
                          </button>
                        ))
                      )}
                    </div>
                  </div>
                  <button
                    onClick={() => setIsSelectingWorkout(false)}
                    className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-300"
                  >
                    뒤로
                  </button>
                </>
              )}
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}



===== FILE: src\components\features\home\TodayWorkoutCard.tsx =====
"use client";

import { useState, useEffect } from "react";
import { useTranslation } from "react-i18next";
import { Play, Clock, Dumbbell, CheckCircle2 } from "lucide-react";
import { formatDuration, getDayLabel } from "@/utils";
import { useSettingsStore } from "@/stores";
import type { WorkoutSummary } from "@/services";
import type { WorkoutWithDetails } from "@/types/workout";

interface TodayWorkoutCardProps {
    splitOrder: string[];
    weekWorkouts: Array<{ start_time: string; name: string | null }>;
    todayWorkout: WorkoutSummary | null;
    todayWorkoutDetail: WorkoutWithDetails | null;
    onStartWorkout?: (workoutName: string) => void;
}

export function TodayWorkoutCard({ splitOrder, weekWorkouts, todayWorkout: initialTodayWorkout, todayWorkoutDetail, onStartWorkout }: TodayWorkoutCardProps) {
    const { t } = useTranslation();
    const language = useSettingsStore((s) => s.language);
    const [nextWorkoutName, setNextWorkoutName] = useState<string | null>(null);

    const getTodayDayIndex = () => {
        const now = new Date();
        const day = now.getDay();
        return day === 0 ? 6 : day - 1;
    };

    const dayLabel = getDayLabel(new Date(), language);

    // 가장 최근 운동 기준 그다음 운동 계산 → nextWorkoutName, 로그
    useEffect(() => {
        const mostRecent = initialTodayWorkout?.name
            ? initialTodayWorkout.name
            : (() => {
                const sorted = [...weekWorkouts].sort((a, b) => new Date(b.start_time).getTime() - new Date(a.start_time).getTime());
                return sorted[0]?.name ?? null;
            })();
        const nextIdx = splitOrder.length > 0 ? (splitOrder.indexOf(mostRecent ?? "") + 1) % splitOrder.length : -1;
        const nextWorkout = nextIdx >= 0 ? splitOrder[nextIdx] : null;

        if (initialTodayWorkout != null) {
            setNextWorkoutName(null);
        } else {
            setNextWorkoutName(nextWorkout);
        }
        console.log("[TodayWorkoutCard] 가장 최근 운동:", mostRecent, "| 분할 운동 리스트:", splitOrder, "| 그다음 운동:", nextWorkout);
    }, [initialTodayWorkout, weekWorkouts, splitOrder]);

    const handleStartWorkout = () => {
        if (!nextWorkoutName) return;
        onStartWorkout?.(nextWorkoutName);
    };

    // 오늘 이미 운동 완료 → 디테일 기록 카드
    if (initialTodayWorkout != null) {
        const r = initialTodayWorkout;
        return (
            <div className="mb-4 rounded-2xl bg-zinc-800 p-6 dark:bg-zinc-900">
                <div className="mb-4 flex items-center gap-2">
                    <div className="flex items-center justify-center w-8 h-8 rounded-lg bg-green-600 text-white text-sm font-bold">
                        {dayLabel}
                    </div>
                    <span className="text-xs font-medium text-green-400 flex items-center gap-1">
                        <CheckCircle2 className="h-3.5 w-3.5" /> {t('home.today.completed')}
                    </span>
                </div>
                <p className="text-xl font-bold text-white dark:text-zinc-100 mb-2">
                    <span className="text-blue-400">{r.name || t('home.today.workout')}</span>
                </p>
                <div className="flex flex-wrap gap-x-4 gap-y-1 text-sm text-zinc-400 dark:text-zinc-400 mb-4">
                    <span className="flex items-center gap-1"><Clock className="h-3.5 w-3.5" />{formatDuration(r.start_time, r.end_time)}</span>
                    <span className="flex items-center gap-1"><Dumbbell className="h-3.5 w-3.5" />{r.total_weight.toLocaleString()}kg · {r.total_sets} {t('workout.sets')}</span>
                </div>

                {todayWorkoutDetail?.exercises && todayWorkoutDetail.exercises.length > 0 ? (
                    <div className="max-h-[280px] overflow-y-auto space-y-3 pr-1 -mr-1">
                        {todayWorkoutDetail.exercises.map((ex, exIdx) => {
                            const sets = (ex.sets || []).filter((s) => s.is_completed);
                            return (
                                <div key={ex.id || exIdx} className="rounded-xl border border-zinc-700/60 bg-zinc-800/50 dark:bg-zinc-900/50 p-3">
                                    <div className="text-sm font-semibold text-zinc-100 mb-2">
                                        {exIdx + 1}. {ex.name}
                                    </div>
                                    {sets.length > 0 ? (
                                        <div className="space-y-1">
                                            {sets.map((set, setIdx) => (
                                                <div key={set.id || setIdx} className="flex justify-between text-sm text-zinc-400">
                                                    <span>{t('workout.set')} {setIdx + 1}</span>
                                                    <span className="font-medium text-zinc-200">{set.weight}kg × {set.reps} {t('workout.reps')}</span>
                                                </div>
                                            ))}
                                        </div>
                                    ) : (
                                        <p className="text-xs text-zinc-500">{t('home.today.noSets')}</p>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                ) : todayWorkoutDetail && (!todayWorkoutDetail.exercises || todayWorkoutDetail.exercises.length === 0) ? (
                    <p className="text-sm text-zinc-500 py-2">{t('home.today.noRecords')}</p>
                ) : (
                    <p className="text-sm text-zinc-500 py-2">{t('home.today.loadDetailError')}</p>
                )}
            </div>
        );
    }

    // 오늘 미완료 → 다음 할 운동 + 시작 버튼
    if (!nextWorkoutName) return null;

    return (
        <div className="mb-4 rounded-2xl bg-zinc-800 p-6 dark:bg-zinc-900">
            <div className="mb-4 flex items-center gap-2">
                <div className="flex items-center justify-center w-8 h-8 rounded-lg bg-blue-600 text-white text-sm font-bold">
                    {dayLabel}
                </div>
            </div>
            <div className="mb-6">
                <p className="text-xl font-bold text-white dark:text-zinc-100 mb-1">
                    {t('home.today.todayIs')} <span className="text-blue-400">{nextWorkoutName}</span>
                </p>
                <p className="text-xl font-bold text-white dark:text-zinc-100">
                    {t('home.today.runDay')} 🔥
                </p>
            </div>
            <button
                onClick={handleStartWorkout}
                className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-4 font-bold text-white transition-transform hover:scale-[1.02] active:scale-[0.98]"
            >
                <span>{t('home.today.startRoutine', { name: nextWorkoutName })}</span>
                <Play className="h-5 w-5 fill-current" />
            </button>
        </div>
    );
}



===== FILE: src\components\features\home\WeeklyGoalModal.tsx =====
"use client";

import { motion, AnimatePresence } from "framer-motion";
import { useState, useEffect } from "react";
import { X } from "lucide-react";

interface WeeklyGoalModalProps {
    isOpen: boolean;
    currentGoal: number | null;
    onSave: (goal: number) => void;
    onClose: () => void;
}

export function WeeklyGoalModal({
    isOpen,
    currentGoal,
    onSave,
    onClose,
}: WeeklyGoalModalProps) {
    const [selectedGoal, setSelectedGoal] = useState<number>(currentGoal || 3);
    const [isSaving, setIsSaving] = useState(false);

    useEffect(() => {
        if (isOpen) {
            setSelectedGoal(currentGoal || 3);
            setIsSaving(false);
        }
    }, [isOpen, currentGoal]);

    const handleSave = async () => {
        setIsSaving(true);
        try {
            await onSave(selectedGoal);
            onClose();
        } catch (error) {
            console.error("Error saving goal:", error);
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <AnimatePresence>
            {isOpen && (
                <div className="fixed inset-0 z-[80] flex items-center justify-center p-4">
                    {/* Backdrop */}
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="absolute inset-0 bg-black/60 backdrop-blur-sm"
                        onClick={onClose}
                    />

                    {/* Modal Content */}
                    <motion.div
                        initial={{ scale: 0.95, opacity: 0, y: 10 }}
                        animate={{ scale: 1, opacity: 1, y: 0 }}
                        exit={{ scale: 0.95, opacity: 0, y: 10 }}
                        className="relative w-full max-w-sm overflow-hidden rounded-3xl bg-white p-6 shadow-2xl dark:bg-zinc-900"
                    >
                        <button
                            onClick={onClose}
                            className="absolute right-4 top-4 rounded-full p-1 text-zinc-500 hover:bg-zinc-100 hover:text-zinc-900 dark:hover:bg-zinc-800 dark:hover:text-zinc-100"
                        >
                            <X className="h-5 w-5" />
                        </button>

                        <div className="flex flex-col">
                            <h2 className="mb-2 text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                                주간 목표 설정
                            </h2>
                            <p className="mb-6 text-sm text-zinc-500 dark:text-zinc-400">
                                주당 운동 횟수를 선택하세요 (최대 7회)
                            </p>

                            {/* Select Input */}
                            <div className="mb-6">
                                <label htmlFor="weeklyGoal" className="sr-only">
                                    주간 목표
                                </label>
                                <select
                                    id="weeklyGoal"
                                    value={selectedGoal}
                                    onChange={(e) => setSelectedGoal(Number(e.target.value))}
                                    className="w-full rounded-xl border border-zinc-200 bg-zinc-50 px-4 py-3 text-center text-lg font-medium outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100"
                                >
                                    {Array.from({ length: 7 }, (_, i) => i + 1).map((num) => (
                                        <option key={num} value={num}>
                                            {num}회
                                        </option>
                                    ))}
                                </select>
                            </div>

                            <div className="flex w-full flex-col gap-3">
                                <button
                                    onClick={handleSave}
                                    disabled={isSaving}
                                    className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white transition-colors hover:bg-blue-700 disabled:opacity-70 disabled:cursor-not-allowed"
                                >
                                    {isSaving ? "저장 중..." : "저장"}
                                </button>
                                <button
                                    onClick={onClose}
                                    disabled={isSaving}
                                    className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 dark:hover:text-zinc-300 disabled:opacity-50"
                                >
                                    취소
                                </button>
                            </div>
                        </div>
                    </motion.div>
                </div>
            )}
        </AnimatePresence>
    );
}



===== FILE: src\components\features\home\WeeklyGoalProgress.tsx =====
"use client";

import { useState } from "react";
import { useTranslation } from "react-i18next";
import { WeeklyGoalModal } from "./WeeklyGoalModal";
import { useUserStore } from "@/stores";
import { saveWeeklyGoal as saveWeeklyGoalService } from "@/services";

interface WeeklyGoalProgressProps {
    weeklyGoal: number | null;
    weekWorkouts: Array<{ start_time: string; name: string | null }>;
    onDataChange?: () => void;
}

export function WeeklyGoalProgress({ weeklyGoal: initialWeeklyGoal, weekWorkouts, onDataChange }: WeeklyGoalProgressProps) {
    const { t } = useTranslation();
    const [weeklyGoal, setWeeklyGoal] = useState<number | null>(initialWeeklyGoal);
    const [isModalOpen, setIsModalOpen] = useState(false);

    const currentWeekWorkouts = new Set(
        weekWorkouts.map((workout) => {
            const date = new Date(workout.start_time);
            return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
        })
    ).size;

    const saveWeeklyGoal = async (goal: number) => {
        try {
            const userId = await useUserStore.getState().getUserId();
            await saveWeeklyGoalService(userId, goal);

            setWeeklyGoal(goal);

            if (onDataChange) {
                onDataChange();
            }

            if (typeof window !== 'undefined') {
                window.dispatchEvent(new CustomEvent('homeDataChanged'));
            }
        } catch (error) {
            console.error("Error saving weekly goal:", error);
            alert(t('home.weeklyGoal.saveError'));
            throw error;
        }
    };

    // Don't show if no goal is set
    if (weeklyGoal === null) {
        return (
            <>
                <div
                    onClick={() => setIsModalOpen(true)}
                    className="mb-4 cursor-pointer rounded-2xl bg-zinc-100 p-4 dark:bg-zinc-900"
                >
                    <p className="text-sm text-zinc-500 dark:text-zinc-400">
                        {t('home.weeklyGoal.setPrompt')}
                    </p>
                </div>
                <WeeklyGoalModal
                    isOpen={isModalOpen}
                    currentGoal={null}
                    onSave={saveWeeklyGoal}
                    onClose={() => setIsModalOpen(false)}
                />
            </>
        );
    }

    const percentage = Math.round((currentWeekWorkouts / weeklyGoal) * 100);

    return (
        <>
            <div
                onClick={() => setIsModalOpen(true)}
                className="mb-4 cursor-pointer rounded-2xl bg-zinc-800 p-4 dark:bg-zinc-900 transition-colors hover:bg-zinc-700 dark:hover:bg-zinc-800"
            >
                <div className="flex items-center justify-between mb-2">
                    <p className="text-sm font-medium text-white dark:text-zinc-100">
                        {t('home.weeklyGoal.progress', { current: currentWeekWorkouts, goal: weeklyGoal })}
                    </p>
                    <p className="text-sm font-bold text-green-500 dark:text-green-400">
                        {percentage}%
                    </p>
                </div>
                <div className="w-full h-2 bg-zinc-700 dark:bg-zinc-800 rounded-full overflow-hidden">
                    <div
                        className="h-full bg-green-500 dark:bg-green-500 rounded-full transition-all duration-300"
                        style={{ width: `${Math.min(percentage, 100)}%` }}
                    />
                </div>
            </div>
            <WeeklyGoalModal
                isOpen={isModalOpen}
                currentGoal={weeklyGoal}
                onSave={saveWeeklyGoal}
                onClose={() => setIsModalOpen(false)}
            />
        </>
    );
}



===== FILE: src\components\features\home\weekly-schedule\index.tsx =====
"use client";

import { useState, useEffect, useRef } from "react";
import { useUserStore, useSettingsStore } from "@/stores";
import { getWorkoutForDate as getWorkoutForDateService } from "@/services";
import { WorkoutWithDetails } from "@/types/workout";
import { WeeklyScheduleProps, DaySchedule } from "./types";
import { getWeekDays, getDayLabel, getWorkoutNameShort, getWorkoutForDate } from "./utils";
import { WeeklyView } from "./WeeklyView";
import { MonthlyCalendarView } from "./MonthlyCalendarView";
import { WorkoutDetailModal } from "@/components/features/workout/detail/WorkoutDetailModal";

export function WeeklySchedule({ splitOrder, weekWorkouts, allWorkouts }: WeeklyScheduleProps) {
  const language = useSettingsStore((s) => s.language);
  const [schedule, setSchedule] = useState<DaySchedule[]>([]);
  const [isExpanded, setIsExpanded] = useState(false);
  const [currentMonth, setCurrentMonth] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [selectedWorkout, setSelectedWorkout] = useState<WorkoutWithDetails | null>(null);
  const [isLoadingWorkout, setIsLoadingWorkout] = useState(false);
  const calendarRef = useRef<HTMLDivElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // Create workout map for all workouts
  const allWorkoutsMap = new Map<string, string>();
  allWorkouts.forEach((workout) => {
    const date = new Date(workout.start_time);
    const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
    if (workout.name) {
      allWorkoutsMap.set(dateKey, workout.name);
    }
  });

  // Handle click outside to close
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      // Don't close if WorkoutDetailModal is open
      if (selectedDate) {
        return;
      }

      // Don't close if clicking on the modal
      if (modalRef.current && modalRef.current.contains(event.target as Node)) {
        return;
      }

      if (isExpanded && calendarRef.current && !calendarRef.current.contains(event.target as Node)) {
        setIsExpanded(false);
      }
    };

    if (isExpanded) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isExpanded, selectedDate]);

  // Fetch workout for selected date
  const fetchWorkoutForDate = async (date: Date) => {
    setIsLoadingWorkout(true);
    setSelectedDate(date);

    try {
      const userId = await useUserStore.getState().getUserId();
      const workout = await getWorkoutForDateService(userId, date);
      setSelectedWorkout(workout);
    } catch (error) {
      console.error("Error fetching workout:", error);
      setSelectedWorkout(null);
    } finally {
      setIsLoadingWorkout(false);
    }
  };

  // Handle date click
  const handleDateClick = (date: Date) => {
    const workoutInfo = getWorkoutForDate(date, allWorkoutsMap, splitOrder, allWorkouts);
    if (workoutInfo.hasWorkout) {
      fetchWorkoutForDate(date);
    }
  };

  useEffect(() => {
    const weekDays = getWeekDays();

    // Create a map of date to workout name
    const workoutMap = new Map<string, string>();
    weekWorkouts.forEach((workout) => {
      const date = new Date(workout.start_time);
      const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
      if (workout.name) {
        workoutMap.set(dateKey, workout.name);
      }
    });

    // Build schedule
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Find the starting workout index for this week
    const getStartingWorkoutIndex = (): number => {
      if (splitOrder.length === 0) return 0;

      const weekStart = weekDays[0];
      let lastWorkoutIndex = -1;
      let lastWorkoutDate: Date | null = null;

      allWorkouts.forEach((workout) => {
        const workoutDate = new Date(workout.start_time);
        if (workoutDate < weekStart && workout.name) {
          const index = splitOrder.indexOf(workout.name);
          if (index !== -1 && (!lastWorkoutDate || workoutDate > lastWorkoutDate)) {
            lastWorkoutIndex = index;
            lastWorkoutDate = workoutDate;
          }
        }
      });

      return lastWorkoutIndex === -1 ? 0 : (lastWorkoutIndex + 1) % splitOrder.length;
    };

    const startingIndex = getStartingWorkoutIndex();

    const calculateWorkoutForDay = (dayIndex: number): string | null => {
      if (splitOrder.length === 0) return null;
      const workoutIndex = (startingIndex + dayIndex) % splitOrder.length;
      return splitOrder[workoutIndex];
    };

    const scheduleData: DaySchedule[] = weekDays.map((date, index) => {
      const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
      const hasWorkout = workoutMap.has(dateKey);
      const workoutName = hasWorkout ? workoutMap.get(dateKey) || null : null;
      const isToday = date.toDateString() === today.toDateString();
      const isPast = date < today;
      const isFuture = date > today;

      let displayWorkoutName: string | null = null;
      let displayWorkoutNameShort: string | null = null;

      if (hasWorkout) {
        displayWorkoutName = workoutName;
        displayWorkoutNameShort = getWorkoutNameShort(workoutName);
      }

      return {
        date,
        dayLabel: getDayLabel(date, language),
        isToday,
        hasWorkout,
        workoutName: displayWorkoutName,
        workoutNameShort: displayWorkoutNameShort,
        isPast,
        isFuture,
      };
    });

    setSchedule(scheduleData);
  }, [splitOrder, weekWorkouts, allWorkouts]);

  if (schedule.length === 0) {
    return null;
  }

  return (
    <>
      {/* Backdrop when expanded */}
      {isExpanded && (
        <div className="fixed inset-0 bg-black/50 z-40" />
      )}

      <div
        ref={calendarRef}
        className={`mb-4 rounded-2xl bg-zinc-100 dark:bg-zinc-900 transition-all duration-300 ${isExpanded
            ? "fixed inset-x-4 top-20 bottom-20 z-50 overflow-y-auto p-4"
            : "p-4"
          }`}
      >
        {!isExpanded ? (
          <WeeklyView schedule={schedule} onExpand={() => setIsExpanded(true)} />
        ) : (
          <MonthlyCalendarView
            currentMonth={currentMonth}
            onMonthChange={setCurrentMonth}
            onDateClick={handleDateClick}
            allWorkoutsMap={allWorkoutsMap}
            splitOrder={splitOrder}
            allWorkouts={allWorkouts}
            language={language}
          />
        )}
      </div>

      {/* Workout Detail Modal */}
      {selectedDate && (
        <WorkoutDetailModal
          selectedDate={selectedDate}
          selectedWorkout={selectedWorkout}
          isLoadingWorkout={isLoadingWorkout}
          onClose={() => {
            setSelectedDate(null);
            setSelectedWorkout(null);
          }}
        />
      )}
    </>
  );
}



===== FILE: src\components\features\home\weekly-schedule\MonthlyCalendarView.tsx =====
"use client";

import { Check, X } from "lucide-react";
import Calendar from "react-calendar";
import "react-calendar/dist/Calendar.css";
import { formatMonthYear, formatShortWeekday } from "@/utils";
import type { DateLocale } from "@/utils";
import { getWorkoutForDate, getWorkoutNameShort } from "./utils";

interface MonthlyCalendarViewProps {
  currentMonth: Date;
  onMonthChange: (date: Date) => void;
  onDateClick: (date: Date) => void;
  allWorkoutsMap: Map<string, string>;
  splitOrder: string[];
  allWorkouts: Array<{ start_time: string; name: string | null }>;
  language: DateLocale;
}

export function MonthlyCalendarView({
  currentMonth,
  onMonthChange,
  onDateClick,
  allWorkoutsMap,
  splitOrder,
  allWorkouts,
  language,
}: MonthlyCalendarViewProps) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Custom tile content for calendar
  const tileContent = ({ date, view }: { date: Date; view: string }) => {
    if (view !== 'month') return null;

    // Don't show workout info for neighboring months
    const isNeighboringMonth = date.getMonth() !== currentMonth.getMonth();
    if (isNeighboringMonth) {
      return null;
    }

    const workoutInfo = getWorkoutForDate(date, allWorkoutsMap, splitOrder, allWorkouts);
    const isPast = date < today;

    return (
      <div className="flex flex-col items-center gap-1 mt-1">
        {workoutInfo.hasWorkout ? (
          <>
            <div className="flex items-center justify-center w-4 h-4 rounded-full bg-green-500">
              <Check className="h-2.5 w-2.5 text-white" />
            </div>
            {workoutInfo.workoutName && (
              <span className="text-[9px] font-medium text-zinc-900 dark:text-zinc-100">
                {getWorkoutNameShort(workoutInfo.workoutName)}
              </span>
            )}
          </>
        ) : isPast ? (
          <div className="flex items-center justify-center w-4 h-4 rounded-full bg-red-500">
            <X className="h-2.5 w-2.5 text-white" />
          </div>
        ) : (
          <div className="flex items-center justify-center w-4 h-4 rounded-full border-2 border-dashed border-zinc-400 dark:border-zinc-600" />
        )}
      </div>
    );
  };

  // Custom tile className
  const tileClassName = ({ date, view }: { date: Date; view: string }) => {
    if (view !== 'month') return null;

    const isToday = date.toDateString() === today.toDateString();
    const workoutInfo = getWorkoutForDate(date, allWorkoutsMap, splitOrder, allWorkouts);

    let className = '';
    if (isToday) {
      className += 'bg-blue-100 dark:bg-blue-900/30 border-2 border-blue-500 ';
    }
    if (workoutInfo.hasWorkout) {
      className += 'font-semibold ';
    }

    return className.trim() || null;
  };

  return (
    <div className="flex flex-col items-center">
      <style jsx global>{`
        .react-calendar {
          width: 100%;
          background: transparent;
          border: none;
          font-family: inherit;
        }
        .react-calendar__navigation {
          display: flex;
          height: 44px;
          margin-bottom: 1em;
        }
        .react-calendar__navigation button {
          min-width: 44px;
          background: none;
          font-size: 16px;
          font-weight: 600;
          color: rgb(39 39 42);
        }
        .dark .react-calendar__navigation button {
          color: rgb(244 244 245);
        }
        .react-calendar__navigation button:enabled:hover,
        .react-calendar__navigation button:enabled:focus {
          background-color: rgb(228 228 231);
        }
        .dark .react-calendar__navigation button:enabled:hover,
        .dark .react-calendar__navigation button:enabled:focus {
          background-color: rgb(39 39 42);
        }
        .react-calendar__navigation button[disabled] {
          background-color: transparent;
        }
        .react-calendar__month-view__weekdays {
          text-align: center;
          text-transform: uppercase;
          font-weight: 600;
          font-size: 0.75em;
          padding: 0.5em 0;
        }
        .react-calendar__month-view__weekdays__weekday {
          padding: 0.5em;
        }
        .react-calendar__month-view__weekdays__weekday abbr {
          text-decoration: none;
        }
        .react-calendar__month-view__days {
          display: grid !important;
          grid-template-columns: repeat(7, 1fr);
          gap: 4px;
        }
        .react-calendar__tile {
          max-width: 100%;
          padding: 0.5em 0.25em;
          background: transparent;
          text-align: center;
          line-height: 14px;
          font-size: 0.75em;
          min-height: 60px;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: flex-start;
          border-radius: 0.5rem;
        }
        .react-calendar__tile:enabled:hover,
        .react-calendar__tile:enabled:focus {
          background-color: rgb(228 228 231);
        }
        .dark .react-calendar__tile:enabled:hover,
        .dark .react-calendar__tile:enabled:focus {
          background-color: rgb(39 39 42);
        }
        .react-calendar__tile--now {
          background: transparent;
        }
        .react-calendar__tile--active {
          background: transparent;
        }
        .react-calendar__tile--neighboringMonth {
          opacity: 0.15;
        }
        .react-calendar__tile--neighboringMonth abbr {
          color: rgb(161 161 170);
        }
        .dark .react-calendar__tile--neighboringMonth abbr {
          color: rgb(63 63 70);
        }
        .react-calendar__month-view__days__day--weekend {
          color: inherit;
        }
        .react-calendar__month-view__days__day--weekend abbr {
          color: inherit;
        }
        .react-calendar__month-view__days__day:nth-child(7n) abbr {
          color: inherit;
        }
      `}</style>
      <Calendar
        onChange={(value) => {
          if (value instanceof Date) {
            onMonthChange(value);
          } else if (Array.isArray(value) && value[0] instanceof Date) {
            onMonthChange(value[0]);
          }
        }}
        onClickDay={onDateClick}
        value={currentMonth}
        formatMonthYear={(_locale, date) => formatMonthYear(date, language)}
        formatShortWeekday={(_locale, date) => formatShortWeekday(date, language)}
        tileContent={tileContent}
        tileClassName={tileClassName}
        next2Label={null}
        prev2Label={null}
        showNeighboringMonth={true}
      />
    </div>
  );
}



===== FILE: src\components\features\home\weekly-schedule\types.ts =====
export interface DaySchedule {
  date: Date;
  dayLabel: string;
  isToday: boolean;
  hasWorkout: boolean;
  workoutName: string | null;
  workoutNameShort: string | null;
  isPast: boolean;
  isFuture: boolean;
}

export interface WeeklyScheduleProps {
  splitOrder: string[];
  weekWorkouts: Array<{ start_time: string; name: string | null }>;
  allWorkouts: Array<{ start_time: string; name: string | null }>;
}



===== FILE: src\components\features\home\weekly-schedule\utils.ts =====
import { getWeekDays, getDayLabel, getWorkoutNameShort } from '@/utils';

// Re-export from utils
export { getWeekDays, getDayLabel, getWorkoutNameShort };

export const getWorkoutForDate = (
  date: Date,
  allWorkoutsMap: Map<string, string>,
  splitOrder: string[],
  allWorkouts: Array<{ start_time: string; name: string | null }>
): { hasWorkout: boolean; workoutName: string | null; scheduledWorkout: string | null } => {
  const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
  const hasWorkout = allWorkoutsMap.has(dateKey);
  const workoutName = hasWorkout ? allWorkoutsMap.get(dateKey) || null : null;

  // Calculate scheduled workout based on split order
  let scheduledWorkout: string | null = null;
  if (!hasWorkout && splitOrder.length > 0) {
    // Find the last completed workout before this date
    let lastWorkoutIndex = -1;
    let lastWorkoutDate: Date | null = null;

    allWorkouts.forEach((workout) => {
      const workoutDate = new Date(workout.start_time);
      if (workoutDate < date && workout.name) {
        const index = splitOrder.indexOf(workout.name);
        if (index !== -1 && (!lastWorkoutDate || workoutDate > lastWorkoutDate)) {
          lastWorkoutIndex = index;
          lastWorkoutDate = workoutDate;
        }
      }
    });

    // Calculate days since last workout
    let daysSinceLastWorkout = 0;
    if (lastWorkoutDate) {
      const lastDate: Date = lastWorkoutDate;
      const diffTime = date.getTime() - lastDate.getTime();
      daysSinceLastWorkout = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    }

    // Calculate the workout index
    const workoutIndex = lastWorkoutIndex === -1
      ? daysSinceLastWorkout % splitOrder.length
      : (lastWorkoutIndex + daysSinceLastWorkout) % splitOrder.length;
    scheduledWorkout = splitOrder[workoutIndex];
  }

  return { hasWorkout, workoutName, scheduledWorkout };
};



===== FILE: src\components\features\home\weekly-schedule\WeeklyView.tsx =====
"use client";

import { Check, X } from "lucide-react";
import { DaySchedule } from "./types";

interface WeeklyViewProps {
  schedule: DaySchedule[];
  onExpand: () => void;
}

export function WeeklyView({ schedule, onExpand }: WeeklyViewProps) {
  return (
    <div
      className="grid grid-cols-7 cursor-pointer"
      onClick={onExpand}
    >
      {schedule.map((day, index) => (
        <div
          key={index}
          className={`flex flex-col items-center gap-2 p-1 rounded-xl ${
            day.isToday
              ? "border-2 border-blue-500 bg-blue-50 dark:bg-blue-900/20"
              : ""
          }`}
        >
          <span className="text-xs font-medium text-zinc-600 dark:text-zinc-400">
            {day.dayLabel}
          </span>

          {day.hasWorkout ? (
            <div className="flex items-center justify-center w-6 h-6 rounded-full bg-green-500">
              <Check className="h-4 w-4 text-white" />
            </div>
          ) : day.isPast ? (
            <div className="flex items-center justify-center w-6 h-6 rounded-full bg-red-500">
              <X className="h-4 w-4 text-white" />
            </div>
          ) : (
            <div className="flex items-center justify-center w-6 h-6 rounded-full border-2 border-dashed border-zinc-400 dark:border-zinc-600" />
          )}

          {day.workoutNameShort && (
            <span className="text-xs font-medium text-zinc-900 dark:text-zinc-100">
              {day.workoutNameShort}
            </span>
          )}

          {day.isToday && (
            <span className="text-[10px] text-zinc-500 dark:text-zinc-400">
              Today
            </span>
          )}
        </div>
      ))}
    </div>
  );
}



===== FILE: src\components\features\profile\index.ts =====
export { SettingsModal } from './SettingsModal';
export { WeightChart } from './WeightChart';



===== FILE: src\components\features\profile\SettingsModal.tsx =====
'use client';

import { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { X, Moon, Sun, Monitor, Globe, Database, User, Info, LogOut, Mail, ChevronRight, Trash2 } from 'lucide-react';
import {
  useSettingsStore,
  useWorkoutHistoryStore,
  useWorkoutAnalyticsStore,
  useExerciseHistoryStore,
  useHomeDataStore,
  useProfileStore,
  useUserStore,
  type ThemeMode,
} from '@/stores';
import { supabase } from '@/lib/supabase';
import { useRouter } from 'next/navigation';
import { getWorkoutsWithDetails, deleteWorkout } from '@/services';
import { WorkoutWithDetails } from '@/types/workout';
import { formatDate, formatDuration } from '@/utils';
import { DeleteConfirmModal } from '@/components';

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function SettingsModal({ isOpen, onClose }: SettingsModalProps) {
  const { t } = useTranslation();
  const { theme, language, setTheme, setLanguage } = useSettingsStore();
  const [activeSection, setActiveSection] = useState<'main' | 'theme' | 'language' | 'data' | 'account' | 'info'>('main');
  const [userInfo, setUserInfo] = useState<{ id: string; email?: string; fullName?: string } | null>(null);
  const router = useRouter();
  
  // Data management state
  const [workouts, setWorkouts] = useState<WorkoutWithDetails[]>([]);
  const [isLoadingWorkouts, setIsLoadingWorkouts] = useState(false);
  const [expandedWorkoutId, setExpandedWorkoutId] = useState<string | null>(null);
  const [deleteTarget, setDeleteTarget] = useState<{ id: string; name: string } | null>(null);
  const refreshWorkoutHistory = useWorkoutHistoryStore((state) => state.refreshWorkoutHistory);

  useEffect(() => {
    if (isOpen && activeSection === 'account') {
      fetchUserInfo();
    }
    if (isOpen && activeSection === 'data') {
      fetchAllWorkouts();
    }
  }, [isOpen, activeSection]);

  const fetchAllWorkouts = async () => {
    setIsLoadingWorkouts(true);
    try {
      const userId = await useUserStore.getState().getUserId();
      const data = await getWorkoutsWithDetails(userId);
      setWorkouts(data);
    } catch (error) {
      console.error('Error fetching workouts:', error);
    } finally {
      setIsLoadingWorkouts(false);
    }
  };

  const handleDeleteWorkout = async () => {
    if (!deleteTarget) return;
    try {
      await deleteWorkout(deleteTarget.id);
      setWorkouts((prev) => prev.filter((w) => w.id !== deleteTarget.id));
      setDeleteTarget(null);
      refreshWorkoutHistory();
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('workoutDeleted'));
      }
    } catch (error) {
      console.error('Error deleting workout:', error);
      alert(t('settings.deleteFailed'));
    }
  };

  // Listen for auth state changes
  useEffect(() => {
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((event, session) => {
      if (session?.user) {
        setUserInfo({
          id: session.user.id,
          email: session.user.email,
          fullName: session.user.user_metadata?.full_name || session.user.user_metadata?.name,
        });
      } else {
        setUserInfo({
          id: 'anon_user',
        });
        // Close modal when user signs out
        if (event === 'SIGNED_OUT') {
          onClose();
        }
      }
      if (activeSection === 'account') {
        fetchUserInfo();
      }
    });

    return () => subscription.unsubscribe();
  }, [activeSection, onClose]);

  const fetchUserInfo = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        setUserInfo({
          id: user.id,
          email: user.email,
          fullName: user.user_metadata?.full_name || user.user_metadata?.name,
        });
      } else {
        setUserInfo({ id: 'anon_user' });
      }
    } catch (error) {
      console.error('Error fetching user info:', error);
      setUserInfo({ id: 'anon_user' });
    }
  };

  const handleLogin = async () => {
    try {
      const { error } = await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/profile`,
        },
      });

      if (error) throw error;
    } catch (error) {
      console.error('Error logging in:', error);
      alert(t('settings.loginFailed'));
    }
  };

  const clearWorkoutHistory = useWorkoutHistoryStore((state) => state.clearWorkoutHistory);
  const clearAnalytics = useWorkoutAnalyticsStore((state) => state.clearAnalytics);
  const clearExerciseCache = useExerciseHistoryStore((state) => state.clearCache);
  const clearHomeData = useHomeDataStore((state) => state.clearHomeData);
  const clearProfile = useProfileStore((state) => state.clearProfile);

  const handleLogout = async () => {
    try {
      // Clear all store data before logout
      clearWorkoutHistory();
      clearAnalytics();
      clearExerciseCache();
      clearHomeData();
      clearProfile();

      // Sign out from Supabase
      await supabase.auth.signOut();

      setUserInfo({ id: 'anon_user' });
      router.refresh();

      // Close the modal after logout
      onClose();
    } catch (error) {
      console.error('Error logging out:', error);
      alert(t('settings.logoutFailed'));
    }
  };

  if (!isOpen) return null;

  const themeOptions: { value: ThemeMode; label: string; icon: typeof Moon }[] = [
    { value: 'light', label: t('settings.light'), icon: Sun },
    { value: 'dark', label: t('settings.dark'), icon: Moon },
    { value: 'system', label: t('settings.system'), icon: Monitor },
  ];

  const languageOptions: { value: 'ko' | 'en'; label: string }[] = [
    { value: 'ko', label: '한국어' },
    { value: 'en', label: 'English' },
  ];

  const renderMainMenu = () => (
    <div className="space-y-2">
   

      <button
        onClick={() => setActiveSection('language')}
        className="w-full flex items-center gap-3 p-4 rounded-xl bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 transition-colors text-left"
      >
        <Globe className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        <div className="flex-1">
          <div className="font-medium text-zinc-900 dark:text-zinc-100">{t('settings.language')}</div>
          <div className="text-sm text-zinc-500 dark:text-zinc-400">
            {language === 'ko' ? '한국어' : 'English'}
          </div>
        </div>
      </button>

      <button
        onClick={() => setActiveSection('data')}
        className="w-full flex items-center gap-3 p-4 rounded-xl bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 transition-colors text-left"
      >
        <Database className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        <div className="flex-1">
          <div className="font-medium text-zinc-900 dark:text-zinc-100">{t('settings.dataManagement')}</div>
          <div className="text-sm text-zinc-500 dark:text-zinc-400">{t('settings.dataManagementDesc')}</div>
        </div>
      </button>

      <button
        onClick={() => setActiveSection('account')}
        className="w-full flex items-center gap-3 p-4 rounded-xl bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 transition-colors text-left"
      >
        <User className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        <div className="flex-1">
          <div className="font-medium text-zinc-900 dark:text-zinc-100">{t('settings.account')}</div>
          <div className="text-sm text-zinc-500 dark:text-zinc-400">{t('settings.accountDesc')}</div>
        </div>
      </button>

      <button
        onClick={() => setActiveSection('info')}
        className="w-full flex items-center gap-3 p-4 rounded-xl bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 transition-colors text-left"
      >
        <Info className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        <div className="flex-1">
          <div className="font-medium text-zinc-900 dark:text-zinc-100">{t('settings.info')}</div>
          <div className="text-sm text-zinc-500 dark:text-zinc-400">{t('settings.infoDesc')}</div>
        </div>
      </button>
    </div>
  );

  const renderThemeSettings = () => (
    <div className="space-y-4">
      <div className="flex items-center gap-3 mb-4">
        <button
          onClick={() => setActiveSection('main')}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
        <h2 className="text-lg font-semibold">{t('settings.darkMode')}</h2>
      </div>

      <div className="space-y-2">
        {themeOptions.map((option) => {
          const Icon = option.icon;
          return (
            <button
              key={option.value}
              onClick={() => setTheme(option.value)}
              className={`w-full flex items-center gap-3 p-4 rounded-xl transition-colors text-left ${theme === option.value
                ? 'bg-blue-600 text-white'
                : 'bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 text-zinc-900 dark:text-zinc-100'
                }`}
            >
              <Icon className="h-5 w-5" />
              <span className="font-medium">{option.label}</span>
              {theme === option.value && (
                <div className="ml-auto w-2 h-2 rounded-full bg-white" />
              )}
            </button>
          );
        })}
      </div>
    </div>
  );

  const renderLanguageSettings = () => (
    <div className="space-y-4">
      <div className="flex items-center gap-3 mb-4">
        <button
          onClick={() => setActiveSection('main')}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
        <h2 className="text-lg font-semibold">{t('settings.language')}</h2>
      </div>

      <div className="space-y-2">
        {languageOptions.map((option) => (
          <button
            key={option.value}
            onClick={() => setLanguage(option.value)}
            className={`w-full flex items-center justify-between p-4 rounded-xl transition-colors text-left ${language === option.value
              ? 'bg-blue-600 text-white'
              : 'bg-zinc-50 dark:bg-zinc-800 hover:bg-zinc-100 dark:hover:bg-zinc-700 text-zinc-900 dark:text-zinc-100'
              }`}
          >
            <span className="font-medium">{option.label}</span>
            {language === option.value && (
              <div className="w-2 h-2 rounded-full bg-white" />
            )}
          </button>
        ))}
      </div>
    </div>
  );

  const renderDataSettings = () => (
    <div className="space-y-4">
      <div className="flex items-center gap-3 mb-4">
        <button
          onClick={() => {
            setActiveSection('main');
            setExpandedWorkoutId(null);
          }}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
        <h2 className="text-lg font-semibold">{t('settings.dataManagement')}</h2>
        <span className="ml-auto text-sm text-zinc-500">{t('settings.count', { n: workouts.length })}</span>
      </div>

      {isLoadingWorkouts ? (
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div key={i} className="h-16 bg-zinc-100 dark:bg-zinc-800 rounded-xl animate-pulse" />
          ))}
        </div>
      ) : workouts.length === 0 ? (
        <div className="text-center py-12 text-zinc-500 dark:text-zinc-400">
          {t('settings.noWorkouts')}
        </div>
      ) : (
        <div className="space-y-2 max-h-[60vh] overflow-y-auto">
          {workouts.map((workout) => (
            <div key={workout.id} className="rounded-xl bg-zinc-50 dark:bg-zinc-800 overflow-hidden">
              <button
                onClick={() => setExpandedWorkoutId(expandedWorkoutId === workout.id ? null : workout.id)}
                className="w-full flex items-center gap-3 p-4 text-left hover:bg-zinc-100 dark:hover:bg-zinc-700 transition-colors"
              >
                <div className="flex-1 min-w-0">
                  <div className="font-medium text-zinc-900 dark:text-zinc-100 truncate">
                    {workout.name || 'Untitled'}
                  </div>
                  <div className="text-sm text-zinc-500 dark:text-zinc-400">
                    {formatDate(workout.start_time)} · {formatDuration(workout.start_time, workout.end_time)}
                  </div>
                </div>
                <ChevronRight className={`h-5 w-5 text-zinc-400 transition-transform ${expandedWorkoutId === workout.id ? 'rotate-90' : ''}`} />
              </button>

              {expandedWorkoutId === workout.id && (
                <div className="px-4 pb-4 space-y-3 border-t border-zinc-200 dark:border-zinc-700">
                  <div className="pt-3 grid grid-cols-2 gap-2 text-sm">
                    <div className="bg-zinc-100 dark:bg-zinc-900 rounded-lg p-2">
                      <div className="text-zinc-500 dark:text-zinc-400">{t('settings.totalVolume')}</div>
                      <div className="font-semibold text-zinc-900 dark:text-zinc-100">{workout.total_weight.toLocaleString()}kg</div>
                    </div>
                    <div className="bg-zinc-100 dark:bg-zinc-900 rounded-lg p-2">
                      <div className="text-zinc-500 dark:text-zinc-400">{t('settings.totalSets')}</div>
                      <div className="font-semibold text-zinc-900 dark:text-zinc-100">{workout.total_sets} {t('workout.sets')}</div>
                    </div>
                  </div>

                  <div className="space-y-2">
                    <div className="text-xs font-medium text-zinc-500 dark:text-zinc-400 uppercase">{t('settings.exerciseList')}</div>
                    {workout.exercises.map((exercise) => (
                      <div key={exercise.id} className="bg-zinc-100 dark:bg-zinc-900 rounded-lg p-3">
                        <div className="font-medium text-zinc-900 dark:text-zinc-100 mb-2">{exercise.name}</div>
                        <div className="space-y-1">
                          {exercise.sets.map((set, idx) => (
                            <div key={set.id} className="flex items-center gap-2 text-sm text-zinc-600 dark:text-zinc-400">
                              <span className="w-5 h-5 flex items-center justify-center rounded bg-zinc-200 dark:bg-zinc-800 text-xs font-medium">
                                {idx + 1}
                              </span>
                              <span>{set.weight}kg × {set.reps}회</span>
                              {set.is_completed && <span className="text-green-500 text-xs">✓</span>}
                            </div>
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>

                  <button
                    onClick={() => setDeleteTarget({ id: workout.id, name: workout.name || t('workout.untitled') })}
                    className="w-full flex items-center justify-center gap-2 p-3 rounded-lg bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30 transition-colors text-sm font-medium"
                  >
                    <Trash2 className="h-4 w-4" />
                    {t('settings.delete')}
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );

  const renderAccountSettings = () => (
    <div className="space-y-4">
      <div className="flex items-center gap-3 mb-4">
        <button
          onClick={() => setActiveSection('main')}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
        <h2 className="text-lg font-semibold">{t('settings.account')}</h2>
      </div>

      <div className="space-y-4">
        {/* Full Name */}
        {userInfo?.fullName && (
          <div className="rounded-xl bg-zinc-50 dark:bg-zinc-800 p-4">
            <div className="text-sm font-medium text-zinc-500 dark:text-zinc-400 mb-2">
              {t('settings.fullName')}
            </div>
            <div className="text-base font-semibold text-zinc-900 dark:text-zinc-100">
              {userInfo.fullName}
            </div>
          </div>
        )}

        {/* Email */}
        {userInfo?.email && (
          <div className="rounded-xl bg-zinc-50 dark:bg-zinc-800 p-4">
            <div className="text-sm font-medium text-zinc-500 dark:text-zinc-400 mb-2">
              {t('settings.email')}
            </div>
            <div className="text-base font-semibold text-zinc-900 dark:text-zinc-100 break-all">
              {userInfo.email}
            </div>
          </div>
        )}

        {/* Sign in / Sign out button (depends on auth state) */}
        <button
          onClick={userInfo?.id === 'anon_user' ? handleLogin : handleLogout}
          className={`w-full flex items-center justify-center gap-3 p-4 rounded-xl transition-colors font-medium ${
            userInfo?.id === 'anon_user'
              ? 'bg-blue-600 text-white hover:bg-blue-700 shadow-lg shadow-blue-500/20'
              : 'bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 hover:bg-red-100 dark:hover:bg-red-900/30'
          }`}
        >
          {userInfo?.id === 'anon_user' ? (
            <>
              <Mail className="h-5 w-5" />
              <span>{t('settings.signInGmail')}</span>
            </>
          ) : (
            <>
              <LogOut className="h-5 w-5" />
              <span>{t('settings.signOut')}</span>
            </>
          )}
        </button>
      </div>
    </div>
  );

  const renderInfoSettings = () => (
    <div className="space-y-4">
      <div className="flex items-center gap-3 mb-4">
        <button
          onClick={() => setActiveSection('main')}
          className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
        >
          <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
        </button>
        <h2 className="text-lg font-semibold">{t('settings.info')}</h2>
      </div>
      <div className="text-center py-12 text-zinc-500 dark:text-zinc-400">
        {t('settings.infoPlaceholder')}
      </div>
    </div>
  );

  return (
    <>
      <div
        className="fixed inset-0 bg-black/50 "
        onClick={onClose}
      />
      <div className="fixed inset-x-0 bottom-0 z-[100] bg-white dark:bg-zinc-900 rounded-t-3xl shadow-2xl max-h-[90vh] overflow-y-auto ">
        <div className="p-4">
          {activeSection === 'main' && (
            <div className="flex items-center justify-between mb-6">
              <h2 className="text-xl font-bold">{t('settings.title')}</h2>
              <button
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
              >
                <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
              </button>
            </div>
          )}

          {activeSection === 'main' && renderMainMenu()}
          {activeSection === 'theme' && renderThemeSettings()}
          {activeSection === 'language' && renderLanguageSettings()}
          {activeSection === 'data' && renderDataSettings()}
          {activeSection === 'account' && renderAccountSettings()}
          {activeSection === 'info' && renderInfoSettings()}
        </div>
      </div>

      <DeleteConfirmModal
        isOpen={!!deleteTarget}
        title={t('settings.deleteWorkoutTitle')}
        message={t('settings.deleteWorkoutMessage', { name: deleteTarget?.name ?? '' })}
        confirmText={t('settings.delete')}
        cancelText={t('common.cancel')}
        onConfirm={handleDeleteWorkout}
        onCancel={() => setDeleteTarget(null)}
      />
    </>
  );
}



===== FILE: src\components\features\profile\WeightChart.tsx =====
'use client';

import { useMemo } from 'react';
import { useTranslation } from 'react-i18next';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { subDays } from 'date-fns';
import { format, parseISO } from '@/utils';
import { WeightRecord } from '@/types/profile';

interface WeightChartProps {
  weightRecords: WeightRecord[];
}

export function WeightChart({ weightRecords }: WeightChartProps) {
  const { t } = useTranslation();
  const chartData = useMemo(() => {
    if (weightRecords.length === 0) return [];

    // Sort by date ascending for chart
    const sorted = [...weightRecords].sort((a, b) => 
      new Date(a.recorded_at).getTime() - new Date(b.recorded_at).getTime()
    );

    // Get date range (last 30 days or all records if less than 30)
    const now = new Date();
    const thirtyDaysAgo = subDays(now, 30);
    
    const filtered = sorted.filter(record => {
      const recordDate = new Date(record.recorded_at);
      return recordDate >= thirtyDaysAgo;
    });

    // If we have records, show them. Otherwise show empty chart message.
    return filtered.map(record => ({
      date: record.recorded_at,
      weight: parseFloat(record.weight.toString()),
      formattedDate: format(parseISO(record.recorded_at), 'MM/dd'),
    }));
  }, [weightRecords]);

  if (weightRecords.length === 0) {
    return (
      <div className="flex items-center justify-center py-12">
        <p className="text-zinc-500 dark:text-zinc-400">{t('profile.noWeightRecords')}</p>
      </div>
    );
  }

  if (chartData.length === 0) {
    return (
      <div className="flex items-center justify-center py-12">
        <p className="text-zinc-500 dark:text-zinc-400">{t('profile.noWeightRecords30d')}</p>
      </div>
    );
  }

  // Calculate min and max for Y-axis with padding
  const weights = chartData.map(d => d.weight);
  const minWeight = Math.min(...weights);
  const maxWeight = Math.max(...weights);
  const padding = (maxWeight - minWeight) * 0.1 || 1;
  const yAxisMin = Math.max(0, minWeight - padding);
  const yAxisMax = maxWeight + padding;

  return (
    <div className="mt-4">
      <ResponsiveContainer width="100%" height={250}>
        <LineChart data={chartData} margin={{ top: 5, right: 10, left: 0, bottom: 5 }}>
          <CartesianGrid strokeDasharray="3 3" stroke="#e4e4e7" className="dark:stroke-zinc-800" />
          <XAxis
            dataKey="formattedDate"
            stroke="#71717a"
            className="text-xs"
            tick={{ fill: '#71717a', fontSize: 12 }}
            interval="preserveStartEnd"
          />
          <YAxis
            domain={[yAxisMin, yAxisMax]}
            stroke="#71717a"
            className="text-xs"
            tick={{ fill: '#71717a', fontSize: 12 }}
            tickFormatter={(value) => value.toFixed(1)}
            label={{ value: 'kg', angle: -90, position: 'insideLeft', fill: '#71717a' }}
          />
          <Tooltip
            contentStyle={{
              backgroundColor: 'white',
              border: '1px solid #e4e4e7',
              borderRadius: '8px',
              padding: '8px 12px',
            }}
            labelStyle={{ color: '#18181b', fontWeight: 600 }}
            formatter={(value: number | undefined) => {
              if (value === undefined) return '';
              return [`${value.toFixed(1)} kg`, '몸무게'];
            }}
            labelFormatter={(label) => `날짜: ${label}`}
          />
          <Line
            type="monotone"
            dataKey="weight"
            stroke="#2563eb"
            strokeWidth={2}
            dot={{ fill: '#2563eb', r: 4 }}
            activeDot={{ r: 6 }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}



===== FILE: src\components\features\workout\index.ts =====
// Session
export {
  ActiveSessionDrawer,
  ExerciseCard,
  AddExerciseModal,
  RestTimerModal,
  WorkoutSummaryModal,
} from './session';
export type { ActiveSessionDrawerProps, ExerciseItem, ExerciseSet } from './session';

// History
export { WorkoutHistoryCard } from './history';

// Detail
export {
  WorkoutDetailDrawer,
  WorkoutDetailModal,
  WorkoutDetailView,
} from './detail';



===== FILE: src\components\features\workout\detail\index.ts =====
export { WorkoutDetailDrawer } from './WorkoutDetailDrawer';
export { WorkoutDetailModal } from './WorkoutDetailModal';
export { WorkoutDetailView } from './WorkoutDetailView';



===== FILE: src\components\features\workout\detail\WorkoutDetailDrawer.tsx =====
"use client";

import { useTranslation } from "react-i18next";
import { Play, X } from "lucide-react";
import { formatDateLong } from "@/utils";
import { useSettingsStore } from "@/stores";
import { WorkoutWithDetails } from "@/types/workout";
import { WorkoutDetailView } from "./WorkoutDetailView";

interface WorkoutDetailDrawerProps {
  workout: WorkoutWithDetails | null;
  isOpen: boolean;
  onClose: () => void;
  onStartRoutine: (workout: WorkoutWithDetails) => void;
}

export function WorkoutDetailDrawer({
  workout,
  isOpen,
  onClose,
  onStartRoutine,
}: WorkoutDetailDrawerProps) {
  const { t } = useTranslation();
  const language = useSettingsStore((s) => s.language);
  if (!isOpen || !workout) return null;

  return (
    <>
      <div
        className="fixed inset-0 z-[60] bg-black/60 backdrop-blur-sm"
        onClick={onClose}
      />
      <div className="fixed inset-x-0 bottom-0 z-[70] flex max-h-[85vh] flex-col rounded-t-3xl bg-white dark:bg-zinc-900 animate-in slide-in-from-bottom duration-300">
        {/* Header */}
        <div className="flex items-center justify-between border-b px-6 py-4 dark:border-zinc-800">
          <div>
            <h2 className="text-xl font-bold text-zinc-900 dark:text-zinc-100">
              {workout.name || t('workout.untitled')}
            </h2>
            <p className="text-sm text-zinc-500 dark:text-zinc-400">
              {formatDateLong(new Date(workout.start_time), language)}
            </p>
          </div>
          <button
            onClick={onClose}
            className="rounded-full p-2 text-zinc-400 hover:bg-zinc-100 hover:text-zinc-600 dark:hover:bg-zinc-800 dark:hover:text-zinc-200"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          <WorkoutDetailView workout={workout} variant="drawer" />
        </div>

        {/* Footer Action */}
        <div className="border-t bg-white p-4 pb-safe dark:bg-zinc-900 dark:border-zinc-800">
          <button
            onClick={() => onStartRoutine(workout)}
            className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white shadow-lg shadow-blue-500/20 transition-transform hover:scale-[1.02] active:scale-[0.98]"
          >
            <Play className="h-5 w-5 fill-current" />
            {t('workout.startWithRoutine')}
          </button>
        </div>
      </div>
    </>
  );
}



===== FILE: src\components\features\workout\detail\WorkoutDetailModal.tsx =====
"use client";

import { useRef } from "react";
import { useTranslation } from "react-i18next";
import { X } from "lucide-react";
import { formatDateLong } from "@/utils";
import { useSettingsStore } from "@/stores";
import { WorkoutWithDetails } from "@/types/workout";
import { WorkoutDetailView } from "./WorkoutDetailView";

interface WorkoutDetailModalProps {
  selectedDate: Date;
  selectedWorkout: WorkoutWithDetails | null;
  isLoadingWorkout: boolean;
  onClose: () => void;
}

export function WorkoutDetailModal({
  selectedDate,
  selectedWorkout,
  isLoadingWorkout,
  onClose,
}: WorkoutDetailModalProps) {
  const { t } = useTranslation();
  const language = useSettingsStore((s) => s.language);
  const modalRef = useRef<HTMLDivElement>(null);

  return (
    <>
      <div
        className="fixed inset-0 bg-black/50 z-[60]"
        onClick={(e) => {
          e.stopPropagation();
          onClose();
        }}
      />
      <div
        ref={modalRef}
        className="fixed inset-x-4 bottom-4 z-[70] bg-white dark:bg-zinc-900 rounded-2xl max-h-[50vh] flex flex-col"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex items-center justify-between p-4 pb-3 flex-shrink-0 border-b border-zinc-200 dark:border-zinc-800">
          <h3 className="text-base font-bold text-zinc-900 dark:text-zinc-100">
            {formatDateLong(selectedDate, language)}
          </h3>
          <button
            onClick={onClose}
            className="p-2 rounded-lg hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors"
          >
            <X className="h-5 w-5 text-zinc-600 dark:text-zinc-400" />
          </button>
        </div>

        <div className="overflow-y-auto p-4 pt-3">
          {isLoadingWorkout ? (
            <div className="flex items-center justify-center py-6">
              <div className="text-sm text-zinc-600 dark:text-zinc-400">{t('workout.loading')}</div>
            </div>
          ) : selectedWorkout ? (
            <WorkoutDetailView workout={selectedWorkout} showStatus={true} variant="modal" />
          ) : (
            <div className="rounded-xl bg-zinc-50 dark:bg-zinc-800 p-4 text-center text-zinc-600 dark:text-zinc-400">
              {t('workout.noRecordForDate')}
            </div>
          )}
        </div>
      </div>
    </>
  );
}



===== FILE: src\components\features\workout\detail\WorkoutDetailView.tsx =====
"use client";

import { useTranslation } from "react-i18next";
import { Check } from "lucide-react";
import { format, formatDateLong } from "@/utils";
import { useSettingsStore } from "@/stores";
import { WorkoutWithDetails } from "@/types/workout";

interface WorkoutDetailViewProps {
  workout: WorkoutWithDetails;
  showDate?: boolean;
  showStatus?: boolean;
  variant?: "modal" | "drawer";
}

export function WorkoutDetailView({
  workout,
  showDate = false,
  showStatus = false,
  variant = "modal",
}: WorkoutDetailViewProps) {
  const { t } = useTranslation();
  const language = useSettingsStore((s) => s.language);
  const isDrawer = variant === "drawer";

  return (
    <div className="space-y-3">
      {/* Workout Header */}
      {showStatus ? (
        <div className="rounded-xl bg-green-50 dark:bg-green-900/20 p-3 border-2 border-green-500">
          <div className="flex items-center gap-3 mb-2">
            <div className="flex items-center justify-center w-10 h-10 rounded-full bg-green-500">
              <Check className="h-6 w-6 text-white" />
            </div>
            <div>
              <div className="text-xs font-medium text-zinc-600 dark:text-zinc-400">
                {t('workout.completed')}
              </div>
              <div className="text-lg font-bold text-green-600 dark:text-green-400">
                {workout.name || t('workout.untitled')}
              </div>
            </div>
          </div>
          {workout.start_time && (
            <div className="text-xs text-zinc-500 dark:text-zinc-400 mt-1">
              {format(new Date(workout.start_time), "HH:mm")} {t('workout.startSuffix')}
              {workout.end_time && ` - ${format(new Date(workout.end_time), "HH:mm")} ${t('workout.endSuffix')}`}
            </div>
          )}
        </div>
      ) : (
        <div>
          <h2 className={`${isDrawer ? "text-xl" : "text-lg"} font-bold text-zinc-900 dark:text-zinc-100`}>
            {workout.name || t('workout.untitled')}
          </h2>
          {showDate && workout.start_time && (
            <p className="text-sm text-zinc-500 dark:text-zinc-400">
              {formatDateLong(new Date(workout.start_time), language)}
            </p>
          )}
        </div>
      )}

      {/* Exercises */}
      {workout.exercises && workout.exercises.length > 0 ? (
        <div className="space-y-2">
          {!isDrawer && (
            <h4 className="text-sm font-semibold text-zinc-900 dark:text-zinc-100">{t('workout.exerciseList')}</h4>
          )}
          {workout.exercises.map((exercise, exerciseIndex) => (
            <div
              key={exercise.id || exerciseIndex}
              className={`${
                isDrawer
                  ? "rounded-xl border border-zinc-100 bg-zinc-50/50 p-4 dark:border-zinc-800 dark:bg-zinc-900/50"
                  : "rounded-xl bg-zinc-50 dark:bg-zinc-800 p-3"
              }`}
            >
              <div className={`${isDrawer ? "mb-3" : "mb-2"} font-semibold text-zinc-900 dark:text-zinc-100`}>
                {isDrawer ? `${exerciseIndex + 1}. ${exercise.name}` : exercise.name}
              </div>
              {exercise.sets && exercise.sets.length > 0 ? (
                isDrawer ? (
                  <>
                    {/* Table Header for Drawer */}
                    <div className="grid grid-cols-12 gap-2 text-xs font-medium text-zinc-500 uppercase tracking-wide text-center mb-2">
                      <div className="col-span-2">{t('workout.set')}</div>
                      <div className="col-span-5">kg</div>
                      <div className="col-span-5">{t('workout.reps')}</div>
                    </div>
                    <div className="space-y-1">
                      {exercise.sets.map((set, setIndex) => (
                        <div key={set.id || setIndex} className="grid grid-cols-12 gap-2 text-sm text-center py-1">
                          <div className="col-span-2 text-zinc-500">{setIndex + 1}</div>
                          <div className="col-span-5 font-medium">{set.weight}</div>
                          <div className="col-span-5 font-medium">{set.reps}</div>
                        </div>
                      ))}
                    </div>
                  </>
                ) : (
                  <div className="space-y-1">
                    {exercise.sets.map((set, setIndex) => (
                      <div
                        key={set.id || setIndex}
                        className="flex items-center justify-between text-base"
                      >
                        <span className="text-zinc-600 dark:text-zinc-400">
                          {t('workout.set')} {setIndex + 1}
                        </span>
                        <span className="text-zinc-900 dark:text-zinc-100 font-semibold">
                          {set.weight}kg × {set.reps} {t('workout.reps')}
                        </span>
                      </div>
                    ))}
                  </div>
                )
              ) : (
                <div className="text-sm text-zinc-500 dark:text-zinc-400">
                  {t('workout.noSetRecords')}
                </div>
              )}
            </div>
          ))}
        </div>
      ) : (
        <div className={`${isDrawer ? "p-4" : "p-3"} rounded-xl bg-zinc-50 dark:bg-zinc-800 text-center text-sm text-zinc-600 dark:text-zinc-400`}>
          {t('home.today.noRecords')}
        </div>
      )}
    </div>
  );
}



===== FILE: src\components\features\workout\history\index.ts =====
export { WorkoutHistoryCard } from './WorkoutHistoryCard';



===== FILE: src\components\features\workout\history\WorkoutHistoryCard.tsx =====
"use client";

import { useState } from "react";
import { useTranslation } from "react-i18next";
import { Clock, Dumbbell, Trash2 } from "lucide-react";
import { DeleteConfirmModal } from "@/components";

interface WorkoutHistoryItemProps {
  id: string; // Added ID
  date: string;
  duration: string;
  totalWeight: number;
  workoutName: string;
  onDelete: (id: string) => void; // Callback for delete
  onClick: () => void; // Callback for click
}

export function WorkoutHistoryCard({
  id,
  date,
  duration,
  totalWeight,
  workoutName,
  onDelete,
  onClick,
}: WorkoutHistoryItemProps) {
  const { t } = useTranslation();
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card click
    setIsDeleteModalOpen(true);
  };

  const handleConfirmDelete = () => {
    onDelete(id);
    setIsDeleteModalOpen(false);
  };

  const handleCancelDelete = () => {
    setIsDeleteModalOpen(false);
  };

  return (
    <>
      <div
        onClick={onClick}
        className="flex flex-col gap-3 rounded-2xl bg-white p-4 shadow-sm transition-all hover:shadow-md active:scale-[0.98] cursor-pointer dark:bg-zinc-900 dark:shadow-zinc-800"
      >
        <div className="flex items-center justify-between">
          <span className="text-xs font-medium text-zinc-500 dark:text-zinc-400">{date}</span>
          <button
            onClick={handleDeleteClick}
            className="p-1 text-zinc-400 hover:text-red-500 transition-colors rounded-full hover:bg-zinc-100 dark:hover:bg-zinc-800"
          >
            <Trash2 className="h-3.5 w-3.5" />
          </button>
        </div>

        <div className="flex items-center justify-between gap-2">
          <h3 className="font-semibold text-zinc-900 dark:text-zinc-100 truncate">{workoutName || t('workout.untitled')}</h3>
         
        </div>

        <div className="mt-auto flex flex-col gap-1 text-xs text-zinc-600 dark:text-zinc-400">
          <div className="flex items-center gap-1.5">
            <Clock className="h-3 w-3" />
            <span>{duration}</span>
          </div>
          <div className="flex items-center gap-1.5">
            <Dumbbell className="h-3 w-3" />
            <span>{totalWeight}kg</span>
          </div>
        </div>
      </div>

      <DeleteConfirmModal
        isOpen={isDeleteModalOpen}
        title={t('workoutHistory.deleteTitle')}
        message={t('workoutHistory.deleteMessage', { name: workoutName || t('workout.untitled') })}
        subMessage={t('workoutHistory.deleteSub')}
        confirmText={t('common.delete')}
        cancelText={t('common.cancel')}
        onConfirm={handleConfirmDelete}
        onCancel={handleCancelDelete}
      />
    </>
  );
}



===== FILE: src\components\features\workout\session\ActiveSessionDrawer.tsx =====
"use client";

import { useEffect, useState, useRef } from "react";
import { useTranslation } from "react-i18next";
import { Plus, X, Edit2 } from "lucide-react";
import { format } from "date-fns";
import { ko, enUS } from "date-fns/locale";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { AddExerciseModal } from "./AddExerciseModal";
import { RestTimerModal } from "./RestTimerModal";
import { WorkoutSummaryModal } from "./WorkoutSummaryModal";
import { DeleteConfirmModal } from "@/components";
import { ExerciseCard, ExerciseItem, ExerciseSet } from "./ExerciseCard";
import { formatTime } from "@/utils";
import { useUserStore, useSettingsStore } from "@/stores";
import { saveWorkout, getRecentWorkoutsWithExercises } from "@/services";

export interface ActiveSessionDrawerProps {
  isOpen: boolean;
  onClose: () => void;
  initialData?: ExerciseItem[];
  initialWorkoutName?: string;
}

export function ActiveSessionDrawer({ isOpen, onClose, initialData, initialWorkoutName }: ActiveSessionDrawerProps) {
  const { t } = useTranslation();
  const language = useSettingsStore((s) => s.language);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [exercises, setExercises] = useState<ExerciseItem[]>([]);
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isSummaryOpen, setIsSummaryOpen] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [isCancelModalOpen, setIsCancelModalOpen] = useState(false);
  const [workoutName, setWorkoutName] = useState("Workout");
  const [isEditingName, setIsEditingName] = useState(false);
  const nameInputRef = useRef<HTMLInputElement>(null);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const [isResting, setIsResting] = useState(false);
  const [restSecondsRemaining, setRestSecondsRemaining] = useState(60);
  const [totalRestSeconds, setTotalRestSeconds] = useState(60);
  const restTimerRef = useRef<NodeJS.Timeout | null>(null);
  const restTimerStartTimeRef = useRef<number | null>(null);
  const restTimerInitialSecondsRef = useRef<number>(60);

  const playBeep = () => {
    if (typeof window !== 'undefined') {
      try {
        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
        if (AudioContext) {
          const ctx = new AudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.type = "sine";
          osc.frequency.value = 880;
          gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.5);
          osc.start();
          osc.stop(ctx.currentTime + 0.5);
        }
      } catch (e) {
        console.error("Audio playback failed", e);
      }

      if (navigator.vibrate) {
        navigator.vibrate([200, 100, 200]);
      }
    }
  };

  useEffect(() => {
    let interval: NodeJS.Timeout;

    if (isOpen && !isSummaryOpen) {
      interval = setInterval(() => {
        setElapsedTime((prev) => prev + 1);
      }, 1000);

      if (initialWorkoutName) {
        setWorkoutName(initialWorkoutName);
      } else if (elapsedTime === 0) {
        const d = new Date();
        const dateStr = format(d, language === 'ko' ? 'yyyy.M.d' : 'M/d/yyyy', { locale: language === 'ko' ? ko : enUS });
        setWorkoutName(t('workout.workoutOn', { date: dateStr }));
      }

      if (initialData && exercises.length === 0) {
        setExercises(initialData);
      }

    } else if (!isOpen) {
      setElapsedTime(0);
      setExercises([]);
      stopRestTimer();
      setIsSummaryOpen(false);
      setIsSaving(false);
      setWorkoutName(t('workout.defaultName'));
      setIsEditingName(false);
    }

    return () => clearInterval(interval);
  }, [isOpen, isSummaryOpen, initialData, initialWorkoutName]);

  useEffect(() => {
    if (isEditingName && nameInputRef.current) {
      nameInputRef.current.focus();
    }
  }, [isEditingName]);

  useEffect(() => {
    if (!isResting) return;

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible' && restTimerStartTimeRef.current !== null) {
        const now = Date.now();
        const elapsed = Math.floor((now - restTimerStartTimeRef.current) / 1000);
        const initialSeconds = restTimerInitialSecondsRef.current;
        const newRemaining = Math.max(0, initialSeconds - elapsed);

        if (newRemaining <= 0) {
          stopRestTimer();
          playBeep();
        } else {
          setRestSecondsRemaining(newRemaining);
        }
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, [isResting]);

  const startRestTimer = () => {
    if (restTimerRef.current) clearInterval(restTimerRef.current);
    const initialSeconds = 60;
    setIsResting(true);
    setRestSecondsRemaining(initialSeconds);
    setTotalRestSeconds(initialSeconds);
    restTimerStartTimeRef.current = Date.now();
    restTimerInitialSecondsRef.current = initialSeconds;

    restTimerRef.current = setInterval(() => {
      if (restTimerStartTimeRef.current === null) return;

      const now = Date.now();
      const elapsed = Math.floor((now - restTimerStartTimeRef.current) / 1000);
      const newRemaining = Math.max(0, restTimerInitialSecondsRef.current - elapsed);

      if (newRemaining <= 0) {
        stopRestTimer();
        playBeep();
      } else {
        setRestSecondsRemaining(newRemaining);
      }
    }, 100);
  };

  const stopRestTimer = () => {
    if (restTimerRef.current) {
      clearInterval(restTimerRef.current);
      restTimerRef.current = null;
    }
    restTimerStartTimeRef.current = null;
    setIsResting(false);
  };

  const addRestTime = (seconds: number) => {
    if (restTimerStartTimeRef.current === null) return;

    const now = Date.now();
    const elapsed = Math.floor((now - restTimerStartTimeRef.current) / 1000);
    const currentRemaining = Math.max(0, restTimerInitialSecondsRef.current - elapsed);
    const newRemaining = Math.max(0, currentRemaining + seconds);

    restTimerInitialSecondsRef.current = newRemaining;
    restTimerStartTimeRef.current = now;

    setRestSecondsRemaining(newRemaining);
    if (seconds > 0) {
      setTotalRestSeconds((prev) => prev + seconds);
    }
  };

  const handleAddExercise = (name: string) => {
    (async () => {
      let templateSets: ExerciseSet[] = [
        {
          id: crypto.randomUUID(),
          weight: 0,
          reps: 0,
          isCompleted: false,
        },
      ];

      try {
        const userId = await useUserStore.getState().getUserId();
        const workoutsData = await getRecentWorkoutsWithExercises(userId);

        if (workoutsData && workoutsData.length > 0) {
          const matchingWorkout = workoutsData.find((workout: any) =>
            workout.exercises?.some(
              (ex: any) => ex.name === name && ex.sets && ex.sets.length > 0
            )
          );

          if (matchingWorkout) {
            const exercise = matchingWorkout.exercises.find(
              (ex: any) => ex.name === name && ex.sets && ex.sets.length > 0
            );

            if (exercise) {
              const sortedSets = [...exercise.sets].sort(
                (a: any, b: any) => a.order - b.order
              );

              templateSets = sortedSets.map((set: any) => ({
                id: crypto.randomUUID(),
                weight: set.weight ?? 0,
                reps: set.reps ?? 0,
                isCompleted: false,
              }));
            }
          }
        }
      } catch (error) {
        console.error("Failed to load previous exercise sets:", error);
      }

      const newExercise: ExerciseItem = {
        id: crypto.randomUUID(),
        name,
        sets: templateSets,
      };

      setExercises((prev) => [...prev, newExercise]);
      setIsAddModalOpen(false);
    })();
  };

  const handleRemoveExercise = (exerciseId: string) => {
    setExercises((prev) => prev.filter((ex) => ex.id !== exerciseId));
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setExercises((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const handleAddSet = (exerciseId: string) => {
    setExercises((prev) =>
      prev.map((ex) => {
        if (ex.id === exerciseId) {
          const lastSet = ex.sets[ex.sets.length - 1];
          const newSet: ExerciseSet = {
            id: crypto.randomUUID(),
            weight: lastSet ? lastSet.weight : 0,
            reps: lastSet ? lastSet.reps : 0,
            isCompleted: false,
          };
          return { ...ex, sets: [...ex.sets, newSet] };
        }
        return ex;
      })
    );
  };

  const handleRemoveSet = (exerciseId: string, setId: string) => {
    setExercises((prev) =>
      prev.map((ex) => {
        if (ex.id === exerciseId) {
          return { ...ex, sets: ex.sets.filter((s) => s.id !== setId) };
        }
        return ex;
      })
    );
  };

  const handleUpdateSet = (
    exerciseId: string,
    setId: string,
    field: "weight" | "reps" | "isCompleted",
    value: number | boolean
  ) => {
    if (field === "isCompleted" && value === true) {
      startRestTimer();
    }

    setExercises((prev) =>
      prev.map((ex) => {
        if (ex.id === exerciseId) {
          return {
            ...ex,
            sets: ex.sets.map((s) => {
              if (s.id === setId) {
                return { ...s, [field]: value };
              }
              return s;
            }),
          };
        }
        return ex;
      })
    );
  };

  const calculateStats = () => {
    let volume = 0;
    let sets = 0;
    exercises.forEach(ex => {
      ex.sets.forEach(set => {
        if (set.isCompleted) {
          volume += set.weight * set.reps;
          sets += 1;
        }
      });
    });
    return { volume, sets };
  };

  const { volume: totalVolume, sets: totalSets } = calculateStats();

  const handleFinishClick = () => {
    stopRestTimer();
    setIsSummaryOpen(true);
  };

  const handleCancelSummary = () => {
    setIsSummaryOpen(false);
  };

  const handleCancelWorkout = () => {
    setIsCancelModalOpen(true);
  };

  const handleConfirmCancel = () => {
    stopRestTimer();
    setIsCancelModalOpen(false);
    onClose();
  };

  const handleCancelCancel = () => {
    setIsCancelModalOpen(false);
  };

  const handleSaveWorkout = async (name: string) => {
    const finalName = name || workoutName;

    try {
      setIsSaving(true);

      const userId = await useUserStore.getState().getUserId();
      const workoutId = crypto.randomUUID();
      const endTime = new Date().toISOString();
      const startTime = new Date(Date.now() - elapsedTime * 1000).toISOString();

      await saveWorkout({
        id: workoutId,
        userId,
        name: finalName,
        startTime,
        endTime,
        totalWeight: totalVolume,
        totalSets,
        exercises: exercises.map((ex) => ({
          id: ex.id,
          name: ex.name,
          sets: ex.sets.map((set) => ({
            id: set.id,
            weight: set.weight,
            reps: set.reps,
            isCompleted: set.isCompleted,
          })),
        })),
      });

      onClose();
      if (typeof window !== 'undefined') {
        window.dispatchEvent(new CustomEvent('workoutSaved'));
      }
    } catch (error) {
      console.error("Save error:", error);
      alert(t('workout.saveError'));
    } finally {
      setIsSaving(false);
    }
  };

  if (!isOpen) return null;

  return (
    <>
      <div className="fixed inset-0 z-[60] flex flex-col bg-white dark:bg-black animate-in slide-in-from-bottom duration-300">
        <header className="flex h-16 items-center justify-between border-b px-4 dark:border-zinc-800">
          <button
            onClick={handleCancelWorkout}
            className="rounded-full p-2 text-zinc-400 hover:bg-zinc-100 hover:text-red-500 dark:hover:bg-zinc-800"
          >
            <X className="h-5 w-5" />
          </button>

          <div className="flex flex-col items-center flex-1 mx-4">
            {isEditingName ? (
              <input
                ref={nameInputRef}
                type="text"
                value={workoutName}
                onChange={(e) => setWorkoutName(e.target.value.slice(0, 8))}
                onBlur={() => setIsEditingName(false)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') setIsEditingName(false);
                }}
                maxLength={8}
                className="w-full max-w-[200px] bg-transparent text-center text-sm font-semibold outline-none border-b border-blue-500 pb-0.5"
              />
            ) : (
              <button
                onClick={() => setIsEditingName(true)}
                className="flex items-center gap-2 text-sm font-semibold hover:text-zinc-600 dark:hover:text-zinc-300 px-2 py-1 rounded"
              >
                <span className="truncate max-w-[180px]">{workoutName}</span>
                <Edit2 className="h-3 w-3 opacity-50" />
              </button>
            )}
            <span className="font-mono text-xs font-medium text-blue-600 dark:text-blue-400 mt-0.5">
              {formatTime(elapsedTime)}
            </span>
          </div>

          <button
            onClick={handleFinishClick}
            disabled={totalSets === 0}
            className="rounded-full bg-zinc-900 px-4 py-1.5 text-xs font-semibold text-white transition-colors hover:bg-zinc-800 dark:bg-zinc-100 dark:text-zinc-900 dark:hover:bg-zinc-200 disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-zinc-900 disabled:dark:hover:bg-zinc-100"
          >
            {t('workout.finish')}
          </button>
        </header>

        <div className="flex-1 overflow-y-auto bg-zinc-50 p-4 pb-4 dark:bg-black">
          {isResting && (
            <div className="mb-4 flex items-center justify-between rounded-xl bg-blue-50 p-3 px-4 text-blue-900 dark:bg-blue-900/20 dark:text-blue-100">
              <span className="text-sm font-medium">{t('workout.resting')}</span>
              <span className="font-mono text-lg font-bold">{formatTime(restSecondsRemaining)}</span>
            </div>
          )}

          {exercises.length === 0 ? (
            <div className="flex  flex-col items-center justify-center text-zinc-500 ">
              <p>{t('workout.tapAddExercise')}</p>
            </div>
          ) : (
            <DndContext
              sensors={sensors}
              collisionDetection={closestCenter}
              onDragEnd={handleDragEnd}
            >
              <SortableContext
                items={exercises.map((ex) => ex.id)}
                strategy={verticalListSortingStrategy}
              >
                <div className="space-y-4">
                  {exercises.map((exercise, index) => (
                    <ExerciseCard
                      key={exercise.id}
                      exercise={exercise}
                      exerciseIndex={index}
                      onRemove={handleRemoveExercise}
                      onAddSet={handleAddSet}
                      onRemoveSet={handleRemoveSet}
                      onUpdateSet={handleUpdateSet}
                    />
                  ))}
                </div>
              </SortableContext>
            </DndContext>
          )}

          <div className="mt-4">
            <button
              onClick={() => setIsAddModalOpen(true)}
              className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-50 py-3.5 font-semibold text-blue-600 transition-colors hover:bg-blue-100 dark:bg-blue-500/10 dark:text-blue-400 dark:hover:bg-blue-500/20"
            >
              <Plus className="h-5 w-5" />
              {t('workout.addExercise')}
            </button>
          </div>
        </div>
      </div>

      <AddExerciseModal
        isOpen={isAddModalOpen}
        onClose={() => setIsAddModalOpen(false)}
        onAdd={handleAddExercise}
        addedExerciseNames={exercises.map((e) => e.name)}
      />

      <RestTimerModal
        isOpen={isResting}
        secondsRemaining={restSecondsRemaining}
        totalSeconds={totalRestSeconds}
        onAddSeconds={addRestTime}
        onSkip={stopRestTimer}
      />

      <WorkoutSummaryModal
        isOpen={isSummaryOpen}
        totalTime={formatTime(elapsedTime)}
        totalVolume={totalVolume}
        totalSets={totalSets}
        isSaving={isSaving}
        initialName={workoutName}
        isNameEditable={!initialWorkoutName}
        onSave={handleSaveWorkout}
        onCancel={handleCancelSummary}
      />

      <DeleteConfirmModal
        isOpen={isCancelModalOpen}
        title={t('workout.cancelWorkout')}
        message={t('workout.cancelProgressLost')}
        confirmText={t('workout.cancelWorkout')}
        cancelText={t('workout.continue')}
        onConfirm={handleConfirmCancel}
        onCancel={handleCancelCancel}
      />
    </>
  );
}



===== FILE: src\components\features\workout\session\AddExerciseModal.tsx =====
"use client";

import { useState, useEffect, useMemo } from "react";
import { useTranslation } from "react-i18next";
import { Search, X } from "lucide-react";
import { useUserStore } from "@/stores";
import { getExerciseNames } from "@/services";

interface AddExerciseModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAdd: (name: string) => void;
  /** 이번 세션에 이미 추가된 운동 이름. Suggestions·검색 결과에서 제외된다. */
  addedExerciseNames?: string[];
}

export function AddExerciseModal({ isOpen, onClose, onAdd, addedExerciseNames = [] }: AddExerciseModalProps) {
  const { t } = useTranslation();
  const [searchTerm, setSearchTerm] = useState("");
  const [existingExercises, setExistingExercises] = useState<string[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  const addedSet = useMemo(() => new Set(addedExerciseNames), [addedExerciseNames]);

  useEffect(() => {
    if (isOpen) {
      const fetchExercises = async () => {
        setIsLoading(true);
        try {
          const userId = await useUserStore.getState().getUserId();
          const names = await getExerciseNames(userId);
          setExistingExercises(names);
        } catch (error) {
          console.error("Error fetching exercise names:", error);
        } finally {
          setIsLoading(false);
        }
      };
      fetchExercises();
      setSearchTerm("");
    }
  }, [isOpen]);

  // 이미 추가된 항목을 제외한 추천 목록 (검색어 없을 때 사용)
  const suggestionsList = useMemo(
    () => existingExercises.filter((name) => !addedSet.has(name)),
    [existingExercises, addedSet]
  );

  // 검색어 기준 필터 + 이미 추가된 항목 제외
  const filteredExercises = useMemo(() => {
    if (!searchTerm.trim()) return [];
    return existingExercises.filter(
      (name) =>
        name.toLowerCase().includes(searchTerm.toLowerCase()) && !addedSet.has(name)
    );
  }, [searchTerm, existingExercises, addedSet]);

  const handleSelect = (name: string) => {
    onAdd(name);
    setSearchTerm("");
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/50 p-4 backdrop-blur-sm animate-in fade-in duration-200">
      <div
        className="flex h-[80vh] w-full max-w-sm flex-col rounded-2xl bg-white p-6 shadow-xl dark:bg-zinc-900 animate-in zoom-in-95 duration-200"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="mb-4 flex items-center justify-between">
          <h3 className="text-lg font-bold text-zinc-900 dark:text-zinc-100">{t('workout.addExerciseTitle')}</h3>
          <button
            onClick={onClose}
            className="rounded-full p-1 text-zinc-500 hover:bg-zinc-100 dark:hover:bg-zinc-800"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        {/* Search Input */}
        <div className="relative mb-4">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-zinc-400" />
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder={t('workout.searchPlaceholder')}
            className="w-full rounded-xl border border-zinc-200 bg-zinc-50 py-3 pl-10 pr-4 outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100"
            autoFocus
          />
        </div>

        {/* List */}
        <div className="flex-1 overflow-y-auto">
          {isLoading ? (
            <div className="flex justify-center py-4">
              <div className="h-5 w-5 animate-spin rounded-full border-2 border-zinc-300 border-t-blue-500" />
            </div>
          ) : (
            <div className="flex flex-col gap-1">
              {/* Create New Option (이미 추가된 이름이면 표시하지 않음) */}
              {searchTerm && !addedSet.has(searchTerm.trim()) && (
                <button
                  onClick={() => handleSelect(searchTerm)}
                  className="flex w-full items-center gap-2 rounded-xl bg-blue-50 px-4 py-3 text-left font-medium text-blue-600 hover:bg-blue-100 dark:bg-blue-500/10 dark:text-blue-400 dark:hover:bg-blue-500/20"
                >
                  <span className="truncate">Create "{searchTerm}"</span>
                </button>
              )}

              {/* Existing Options */}
              {filteredExercises.map((name) => (
                <button
                  key={name}
                  onClick={() => handleSelect(name)}
                  className="w-full rounded-xl px-4 py-3 text-left font-medium text-zinc-700 hover:bg-zinc-100 dark:text-zinc-300 dark:hover:bg-zinc-800"
                >
                  {name}
                </button>
              ))}

              {!searchTerm && suggestionsList.length > 0 && (
                <div className="px-4 py-2 text-xs font-medium text-zinc-500 uppercase tracking-wide">
                  {t('workout.suggestions')}
                </div>
              )}
              {!searchTerm && suggestionsList.map((name) => (
                <button
                  key={`suggestion-${name}`}
                  onClick={() => handleSelect(name)}
                  className="w-full rounded-xl px-4 py-3 text-left font-medium text-zinc-700 hover:bg-zinc-100 dark:text-zinc-300 dark:hover:bg-zinc-800"
                >
                  {name}
                </button>
              ))}

              {!searchTerm && suggestionsList.length === 0 && (
                <div className="text-center py-8 text-zinc-500 text-sm">
                  {t('workout.noExercises')}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}



===== FILE: src\components\features\workout\session\ExerciseCard.tsx =====
"use client";

import { useTranslation } from "react-i18next";
import { Check, Plus, X, GripVertical } from "lucide-react";
import { motion, useMotionValue, useTransform, animate, PanInfo } from "framer-motion";
import { useState } from "react";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { DeleteConfirmModal } from "@/components";

export interface ExerciseSet {
  id: string;
  weight: number;
  reps: number;
  isCompleted: boolean;
}

export interface ExerciseItem {
  id: string;
  name: string;
  sets: ExerciseSet[];
}

interface ExerciseCardProps {
  exercise: ExerciseItem;
  exerciseIndex: number;
  onRemove: (id: string) => void;
  onUpdateSet: (exerciseId: string, setId: string, field: "weight" | "reps" | "isCompleted", value: number | boolean) => void;
  onAddSet: (exerciseId: string) => void;
  onRemoveSet: (exerciseId: string, setId: string) => void;
}

interface ExerciseSetRowProps {
  set: ExerciseSet;
  index: number;
  exerciseId: string;
  onUpdateSet: (exerciseId: string, setId: string, field: "weight" | "reps" | "isCompleted", value: number | boolean) => void;
  onRemoveSet: (exerciseId: string, setId: string) => void;
}

function ExerciseSetRow({ set, index, exerciseId, onUpdateSet, onRemoveSet }: ExerciseSetRowProps) {
  const x = useMotionValue(0);
  const [isDeleteMode, setIsDeleteMode] = useState(false);

  // Swipe Logic
  const handlePan = (event: Event, info: PanInfo) => {
    // Only allow swiping left
    let newX = x.get() + info.delta.x;
    // Clamp values: 0 to -60 (just enough to toggle)
    if (newX > 0) newX = 0;
    if (newX < -60) newX = -60;
    x.set(newX);
  };

  const handlePanEnd = () => {
    const currentX = x.get();
    if (currentX < -30) {
      // Snap to delete state
      animate(x, -50, { type: "spring", stiffness: 400, damping: 30 });
      setIsDeleteMode(true);
    } else {
      // Snap back to normal
      animate(x, 0, { type: "spring", stiffness: 400, damping: 30 });
      setIsDeleteMode(false);
    }
  };

  // Button Transforms
  // Check Button: Slide Left (-20px) and Fade Out
  const checkOpacity = useTransform(x, [0, -40], [1, 0]);
  const checkX = useTransform(x, [0, -40], [0, -20]);
  const checkScale = useTransform(x, [0, -40], [1, 0.8]);
  const checkPointerEvents = useTransform(x, (latest) => latest < -25 ? "none" : "auto");

  // Delete Button: Slide In (from 20px) and Fade In
  const deleteOpacity = useTransform(x, [-10, -50], [0, 1]);
  const deleteX = useTransform(x, [-10, -50], [20, 0]);
  const deleteScale = useTransform(x, [-10, -50], [0.8, 1]);
  const deletePointerEvents = useTransform(x, (latest) => latest < -25 ? "auto" : "none");

  return (
    <div
      className={`relative overflow-hidden ${set.isCompleted
        ? "bg-green-50/50 dark:bg-green-900/10"
        : "even:bg-zinc-50/50 dark:even:bg-zinc-900/50"
        }`}
    >
      <motion.div
        onPan={handlePan}
        onPanEnd={handlePanEnd}
        style={{ touchAction: "pan-y" }}
        className="grid grid-cols-10 gap-2 px-4 py-2 items-center"
      >
        <div className="col-span-1 text-center font-medium text-zinc-500">
          {index + 1}
        </div>

        <div className="col-span-3">
          <input
            type="number"
            value={set.weight || ""}
            onFocus={(e) => {
              // 클릭 시 값 리셋
              e.target.select();
              onUpdateSet(exerciseId, set.id, "weight", 0);
            }}
            onChange={(e) => {
              const inputValue = e.target.value;
              // 빈 값 허용 (사용자가 삭제 중일 수 있음)
              if (inputValue === "") {
                onUpdateSet(exerciseId, set.id, "weight", 0);
                return;
              }
              const numValue = Number(inputValue);
              // NaN 체크
              if (isNaN(numValue)) {
                return;
              }
              // 범위 제한: 0 이상, 1000kg 이하 (validation.ts와 일치)
              const clampedValue = Math.max(0, Math.min(1000, numValue));
              onUpdateSet(exerciseId, set.id, "weight", clampedValue);
            }}
            min={0}
            max={1000}
            step={0.1}
            className={`w-full rounded-md border bg-transparent px-2 py-1.5 text-center text-sm font-semibold outline-none focus:ring-2 focus:ring-blue-500 ${set.isCompleted
              ? "border-green-200 text-green-700 dark:border-green-800 dark:text-green-400"
              : "border-zinc-200 text-zinc-900 dark:border-zinc-700 dark:text-zinc-100"
              }`}
            placeholder="0"
          />
        </div>

        <div className="col-span-3">
          <input
            type="number"
            value={set.reps || ""}
            onFocus={(e) => {
              // 클릭 시 값 리셋
              e.target.select();
              onUpdateSet(exerciseId, set.id, "reps", 0);
            }}
            onChange={(e) => {
              const inputValue = e.target.value;
              // 빈 값 허용 (사용자가 삭제 중일 수 있음)
              if (inputValue === "") {
                onUpdateSet(exerciseId, set.id, "reps", 0);
                return;
              }
              const numValue = Number(inputValue);
              // NaN 체크
              if (isNaN(numValue)) {
                return;
              }
              // 범위 제한: 1 이상, 1000회 이하 (validation.ts와 일치)
              const clampedValue = Math.max(1, Math.min(1000, numValue));
              onUpdateSet(exerciseId, set.id, "reps", Math.floor(clampedValue)); // 정수로 변환
            }}
            min={1}
            max={1000}
            step={1}
            className={`w-full rounded-md border bg-transparent px-2 py-1.5 text-center text-sm font-semibold outline-none focus:ring-2 focus:ring-blue-500 ${set.isCompleted
              ? "border-green-200 text-green-700 dark:border-green-800 dark:text-green-400"
              : "border-zinc-200 text-zinc-900 dark:border-zinc-700 dark:text-zinc-100"
              }`}
            placeholder="0"
          />
        </div>

        {/* Action Button Container */}
        <div className="col-span-3 flex justify-center relative h-8">
          {/* Check Button (Done) */}
          <motion.button
            style={{
              opacity: checkOpacity,
              x: checkX,
              scale: checkScale,
              pointerEvents: checkPointerEvents,
            }}
            onClick={() => onUpdateSet(exerciseId, set.id, "isCompleted", !set.isCompleted)}
            className={`absolute inset-0 flex items-center justify-center rounded-md transition-colors ${set.isCompleted
              ? "bg-green-500 text-white shadow-sm hover:bg-green-600"
              : "bg-zinc-100 text-zinc-400 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-500 dark:hover:bg-zinc-700"
              }`}
          >
            <Check className={`h-4 w-4 ${set.isCompleted ? "stroke-[3px]" : ""}`} />
          </motion.button>

          {/* Delete Button (X) */}
          <motion.button
            style={{
              opacity: deleteOpacity,
              x: deleteX,
              scale: deleteScale,
              pointerEvents: deletePointerEvents,
            }}
            onClick={() => {
              onRemoveSet(exerciseId, set.id);
              setIsDeleteMode(false);
              animate(x, 0, { type: "spring", stiffness: 400, damping: 30 });
            }}
            className="absolute inset-0 flex items-center justify-center rounded-md bg-red-500 text-white shadow-sm hover:bg-red-600"
          >
            <X className="h-4 w-4" />
          </motion.button>
        </div>
      </motion.div>
    </div>
  );
}

export function ExerciseCard({
  exercise,
  exerciseIndex,
  onRemove,
  onUpdateSet,
  onAddSet,
  onRemoveSet,
}: ExerciseCardProps) {
  const { t } = useTranslation();
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: exercise.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className="rounded-xl border border-zinc-100 bg-white shadow-sm dark:border-zinc-800 dark:bg-zinc-900"
    >
      {/* Header */}
      <div className="flex items-center justify-between border-b px-4 py-3 dark:border-zinc-800">
        <div className="flex items-center gap-2">
          <button
            {...attributes}
            {...listeners}
            className="cursor-grab active:cursor-grabbing touch-none text-zinc-400 hover:text-zinc-600 dark:hover:text-zinc-300 p-1 -ml-1"
            aria-label="Drag to reorder"
          >
            <GripVertical className="h-5 w-5" />
          </button>
          <h3 className="font-semibold text-blue-600 dark:text-blue-400">
            {exerciseIndex + 1}. {exercise.name}
          </h3>
        </div>
        <button
          onClick={() => setIsDeleteModalOpen(true)}
          className="text-zinc-400 hover:text-red-500"
        >
          <X className="h-4 w-4" />
        </button>
      </div>

      {/* Table Header */}
      <div className="grid grid-cols-10 gap-2 px-4 py-2 text-xs font-medium text-zinc-500 uppercase tracking-wide text-center">
        <div className="col-span-1">{t('workout.set')}</div>
        <div className="col-span-3">kg</div>
        <div className="col-span-3">{t('workout.reps')}</div>
        <div className="col-span-3">{t('workout.done')}</div>
      </div>

      {/* Sets */}
      <div className="flex flex-col overflow-hidden">
        {exercise.sets.map((set, index) => (
          <ExerciseSetRow
            key={set.id}
            set={set}
            index={index}
            exerciseId={exercise.id}
            onUpdateSet={onUpdateSet}
            onRemoveSet={onRemoveSet}
          />
        ))}
      </div>

      {/* Add Set Button */}
      <div className="p-3">
        <button
          onClick={() => onAddSet(exercise.id)}
          className="flex w-full items-center justify-center gap-2 rounded-lg bg-zinc-50 py-2.5 text-sm font-semibold text-blue-600 hover:bg-zinc-100 dark:bg-zinc-800/50 dark:text-blue-400 dark:hover:bg-zinc-800"
        >
          <Plus className="h-4 w-4" />
          {t('workout.addSet')}
        </button>
      </div>

      <DeleteConfirmModal
        isOpen={isDeleteModalOpen}
        title={t('workout.deleteExercise')}
        message={t('workout.deleteExerciseConfirm', { name: exercise.name })}
        subMessage={t('workout.deleteExerciseSub')}
        confirmText={t('common.delete')}
        cancelText={t('common.cancel')}
        onConfirm={() => {
          onRemove(exercise.id);
          setIsDeleteModalOpen(false);
        }}
        onCancel={() => setIsDeleteModalOpen(false)}
      />
    </div>
  );
}



===== FILE: src\components\features\workout\session\index.ts =====
export { ActiveSessionDrawer } from './ActiveSessionDrawer';
export type { ActiveSessionDrawerProps } from './ActiveSessionDrawer';
export { ExerciseCard } from './ExerciseCard';
export type { ExerciseItem, ExerciseSet } from './ExerciseCard';
export { AddExerciseModal } from './AddExerciseModal';
export { RestTimerModal } from './RestTimerModal';
export { WorkoutSummaryModal } from './WorkoutSummaryModal';



===== FILE: src\components\features\workout\session\RestTimerModal.tsx =====
"use client";

import { useTranslation } from "react-i18next";
import { Plus, Minus, SkipForward } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { formatTime } from "@/utils";

interface RestTimerModalProps {
  isOpen: boolean;
  secondsRemaining: number;
  totalSeconds: number; // For progress calculation
  onAddSeconds: (seconds: number) => void;
  onSkip: () => void;
}

export function RestTimerModal({
  isOpen,
  secondsRemaining,
  totalSeconds,
  onAddSeconds,
  onSkip,
}: RestTimerModalProps) {
  const { t } = useTranslation();
  // Calculate progress for the circle (0 to 1)
  // When secondsRemaining == totalSeconds, progress is 1.
  // When 0, progress is 0.
  const progress = Math.min(Math.max(secondsRemaining / totalSeconds, 0), 1);
  const circumference = 2 * Math.PI * 120; // Radius 120
  const strokeDashoffset = circumference * (1 - progress);

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[80] flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onSkip} // clicking outside skips/closes
          />

          {/* Modal Content */}
          <motion.div
            initial={{ scale: 0.9, opacity: 0, y: 20 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.9, opacity: 0, y: 20 }}
            className="relative w-full max-w-sm rounded-3xl bg-white p-8 shadow-2xl dark:bg-zinc-900"
          >
            <div className="flex flex-col items-center">
              <h3 className="mb-8 text-xl font-bold text-zinc-900 dark:text-zinc-100">{t('workout.restingTitle')}</h3>

              {/* Pomodoro Circle Timer */}
              <div className="relative mb-8 flex items-center justify-center">
                {/* Background Circle */}
                <svg className="h-64 w-64 -rotate-90 transform">
                  <circle
                    cx="128"
                    cy="128"
                    r="120"
                    stroke="currentColor"
                    strokeWidth="8"
                    fill="transparent"
                    className="text-zinc-100 dark:text-zinc-800"
                  />
                  {/* Progress Circle */}
                  <circle
                    cx="128"
                    cy="128"
                    r="120"
                    stroke="currentColor"
                    strokeWidth="8"
                    fill="transparent"
                    strokeLinecap="round"
                    className="text-blue-500 transition-all duration-1000 ease-linear"
                    style={{
                      strokeDasharray: circumference,
                      strokeDashoffset: strokeDashoffset,
                    }}
                  />
                </svg>

                {/* Time Display */}
                <div className="absolute flex flex-col items-center">
                  <span className="text-5xl font-mono font-bold tracking-tighter text-zinc-900 dark:text-zinc-50">
                    {formatTime(secondsRemaining)}
                  </span>
                  <span className="text-sm font-medium text-zinc-500 mt-2">{t('workout.nextSet')}</span>
                </div>
              </div>

              {/* Controls */}
              <div className="grid w-full grid-cols-3 gap-3">
                <button
                  onClick={() => onAddSeconds(-10)}
                  className="flex flex-col items-center gap-1 rounded-2xl bg-zinc-100 p-3 hover:bg-zinc-200 dark:bg-zinc-800 dark:hover:bg-zinc-700 transition-colors"
                >
                  <Minus className="h-5 w-5" />
                  <span className="text-xs font-semibold">-10s</span>
                </button>

                <button
                  onClick={() => onAddSeconds(10)}
                  className="flex flex-col items-center gap-1 rounded-2xl bg-zinc-100 p-3 hover:bg-zinc-200 dark:bg-zinc-800 dark:hover:bg-zinc-700 transition-colors"
                >
                  <Plus className="h-5 w-5" />
                  <span className="text-xs font-semibold">+10s</span>
                </button>

                <button
                  onClick={onSkip}
                  className="flex flex-col items-center gap-1 rounded-2xl bg-red-50 p-3 text-red-600 hover:bg-red-100 dark:bg-red-500/10 dark:text-red-400 dark:hover:bg-red-500/20 transition-colors"
                >
                  <SkipForward className="h-5 w-5" />
                  <span className="text-xs font-semibold">{t('workout.skip')}</span>
                </button>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}



===== FILE: src\components\features\workout\session\WorkoutSummaryModal.tsx =====
"use client";

import { useTranslation } from "react-i18next";
import { CheckCircle2, Loader2 } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { useState, useEffect } from "react";

interface WorkoutSummaryModalProps {
  isOpen: boolean;
  totalTime: string;
  totalVolume: number;
  totalSets: number;
  isSaving: boolean;
  initialName?: string;
  isNameEditable?: boolean; // Whether name can be edited
  onSave: (name: string) => void;
  onCancel: () => void;
}

export function WorkoutSummaryModal({
  isOpen,
  totalTime,
  totalVolume,
  totalSets,
  isSaving,
  initialName = "",
  isNameEditable = true,
  onSave,
  onCancel,
}: WorkoutSummaryModalProps) {
  const { t } = useTranslation();
  const [name, setName] = useState(initialName);

  // Sync with prop when opening
  useEffect(() => {
    if (isOpen) {
      setName(initialName);
    }
  }, [isOpen, initialName]);

  const handleSaveClick = () => {
    if (name.trim()) {
      onSave(name.trim());
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-[80] flex items-center justify-center p-4">
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={!isSaving ? onCancel : undefined}
          />

          {/* Modal Content */}
          <motion.div
            initial={{ scale: 0.95, opacity: 0, y: 10 }}
            animate={{ scale: 1, opacity: 1, y: 0 }}
            exit={{ scale: 0.95, opacity: 0, y: 10 }}
            className="relative w-full max-w-sm overflow-hidden rounded-3xl bg-white p-6 shadow-2xl dark:bg-zinc-900"
          >
            <div className="flex flex-col items-center text-center">
              <div className="mb-4 rounded-full bg-green-100 p-3 text-green-600 dark:bg-green-900/30 dark:text-green-400">
                <CheckCircle2 className="h-8 w-8" />
              </div>

              <h2 className="mb-2 text-2xl font-bold text-zinc-900 dark:text-zinc-100">
                {t('workout.summaryComplete')}
              </h2>
              <p className="mb-6 text-sm text-zinc-500 dark:text-zinc-400">
                {isNameEditable ? t('workout.summaryConfirmName') : t('workout.summaryWillSave')}
              </p>

              {/* Name Input */}
              <div className="w-full mb-6">
                <label htmlFor="workoutName" className="sr-only">Workout Name</label>
                {isNameEditable ? (
                  <input
                    id="workoutName"
                    type="text"
                    placeholder={t('workout.summaryNamePlaceholder')}
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                    className="w-full rounded-xl border border-zinc-200 bg-zinc-50 px-4 py-3 text-center font-medium outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100"
                    autoFocus
                  />
                ) : (
                  <div className="w-full rounded-xl border border-zinc-200 bg-zinc-50 px-4 py-3 text-center font-medium dark:border-zinc-800 dark:bg-zinc-950 dark:text-zinc-100 text-zinc-600 dark:text-zinc-400">
                    {name || t('workout.untitled')}
                  </div>
                )}
              </div>

              <div className="mb-8 grid w-full grid-cols-3 gap-4">
                <div className="flex flex-col items-center gap-1 rounded-2xl bg-zinc-50 p-4 dark:bg-zinc-800/50">
                  <span className="text-xs font-medium text-zinc-500 uppercase tracking-wide">{t('workout.time')}</span>
                  <span className="font-mono text-lg font-bold text-zinc-900 dark:text-zinc-100">{totalTime}</span>
                </div>
                <div className="flex flex-col items-center gap-1 rounded-2xl bg-zinc-50 p-4 dark:bg-zinc-800/50">
                  <span className="text-xs font-medium text-zinc-500 uppercase tracking-wide">{t('workout.volume')}</span>
                  <span className="font-mono text-lg font-bold text-zinc-900 dark:text-zinc-100">{totalVolume}kg</span>
                </div>
                <div className="flex flex-col items-center gap-1 rounded-2xl bg-zinc-50 p-4 dark:bg-zinc-800/50">
                  <span className="text-xs font-medium text-zinc-500 uppercase tracking-wide">{t('workout.sets')}</span>
                  <span className="font-mono text-lg font-bold text-zinc-900 dark:text-zinc-100">{totalSets}</span>
                </div>
              </div>

              <div className="flex w-full flex-col gap-3">
                <button
                  onClick={handleSaveClick}
                  disabled={isSaving || !name.trim()}
                  className="flex w-full items-center justify-center gap-2 rounded-xl bg-blue-600 py-3.5 font-bold text-white transition-colors hover:bg-blue-700 disabled:opacity-70 disabled:cursor-not-allowed"
                >
                  {isSaving ? (
                    <>
                      <Loader2 className="h-5 w-5 animate-spin" />
                      {t('workout.saving')}
                    </>
                  ) : (
                    t('workout.saveFinish')
                  )}
                </button>
                <button
                  onClick={onCancel}
                  disabled={isSaving}
                  className="w-full rounded-xl py-3.5 font-medium text-zinc-500 hover:text-zinc-900 disabled:opacity-50 dark:hover:text-zinc-300"
                >
                  {t('workout.cancel')}
                </button>
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}



===== FILE: src\components\providers\AuthProvider.tsx =====
'use client';

import { useEffect, useRef } from 'react';
import { supabase } from '@/lib/supabase';
import {
  useWorkoutHistoryStore,
  useWorkoutAnalyticsStore,
  useExerciseHistoryStore,
  useHomeDataStore,
  useProfileStore,
  useUserStore,
} from '@/stores';

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const clearWorkoutHistory = useWorkoutHistoryStore((state) => state.clearWorkoutHistory);
  const clearAnalytics = useWorkoutAnalyticsStore((state) => state.clearAnalytics);
  const clearExerciseCache = useExerciseHistoryStore((state) => state.clearCache);
  const clearHomeData = useHomeDataStore((state) => state.clearHomeData);
  const clearProfile = useProfileStore((state) => state.clearProfile);
  const fetchWorkoutHistory = useWorkoutHistoryStore((state) => state.fetchWorkoutHistory);
  const fetchAnalytics = useWorkoutAnalyticsStore((state) => state.fetchAnalytics);
  const fetchHomeData = useHomeDataStore((state) => state.fetchHomeData);
  const refreshProfile = useProfileStore((state) => state.refreshProfile);

  const previousUserIdRef = useRef<string | null>(null);

  useEffect(() => {
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      const currentUserId = session?.user?.id || 'anon_user';
      const previousUserId = previousUserIdRef.current;

      if (event === 'SIGNED_OUT') {
        clearWorkoutHistory();
        clearAnalytics();
        clearExerciseCache();
        clearHomeData();
        clearProfile();
        useUserStore.getState().clearUser();
        previousUserIdRef.current = null;
      } else if (event === 'SIGNED_IN' && previousUserId !== currentUserId) {
        if (previousUserId !== null) {
          clearWorkoutHistory();
          clearAnalytics();
          clearExerciseCache();
          clearHomeData();
          clearProfile();
        }
        await Promise.all([
          fetchWorkoutHistory(),
          fetchAnalytics(),
          fetchHomeData(),
          refreshProfile(),
        ]);
        previousUserIdRef.current = currentUserId;
      } else if (event === 'TOKEN_REFRESHED' && previousUserId === currentUserId) {
        return;
      }
    });

    supabase.auth.getUser().then(({ data: { user } }) => {
      previousUserIdRef.current = user?.id || 'anon_user';
    });

    return () => subscription.unsubscribe();
  }, [
    clearWorkoutHistory,
    clearAnalytics,
    clearExerciseCache,
    clearHomeData,
    clearProfile,
    fetchWorkoutHistory,
    fetchAnalytics,
    fetchHomeData,
    refreshProfile,
  ]);

  return <>{children}</>;
}



===== FILE: src\components\providers\I18nProvider.tsx =====
'use client';

import { useEffect } from 'react';
import i18n from '../../i18n/config';
import { useSettingsStore } from '@/stores';

export function I18nProvider({ children }: { children: React.ReactNode }) {
  const language = useSettingsStore((s) => s.language);

  useEffect(() => {
    i18n.changeLanguage(language);
    if (typeof document !== 'undefined') document.documentElement.lang = language;
  }, [language]);

  return <>{children}</>;
}



===== FILE: src\components\providers\index.ts =====
export { AuthProvider } from './AuthProvider';
export { ThemeProvider } from './ThemeProvider';
export { I18nProvider } from './I18nProvider';



===== FILE: src\components\providers\ThemeProvider.tsx =====
'use client';

import { useEffect } from 'react';
import { useSettingsStore } from '@/stores';

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const loadSettings = useSettingsStore((state) => state.loadSettings);

  useEffect(() => {
    loadSettings();
  }, [loadSettings]);

  return <>{children}</>;
}



===== FILE: src\i18n\config.ts =====
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import en from './locales/en.json';
import ko from './locales/ko.json';

i18n.use(initReactI18next).init({
  resources: { en: { translation: en }, ko: { translation: ko } },
  lng: 'en',
  fallbackLng: 'en',
  interpolation: { escapeValue: false },
  react: { useSuspense: false },
});

export default i18n;



===== FILE: src\i18n\locales\en.json =====
{
  "nav": {
    "home": "Home",
    "workout": "Workout",
    "data": "Data",
    "profile": "Profile"
  },
  "home": {
    "title": "Home",
    "weeklyGoal": {
      "setPrompt": "Set your weekly goal",
      "progress": "This week: {{current}} / {{goal}}",
      "saveError": "Failed to save goal"
    },
    "split": {
      "setPrompt": "Set up your split",
      "splitCount": "{{count}}-day split",
      "changeSplit": "Change split",
      "saveCountError": "Failed to save split count",
      "saveOrderError": "Failed to save split order",
      "saveProgramFirst": "Save a workout first."
    },
    "today": {
      "completed": "Done today",
      "workout": "Workout",
      "noSets": "No completed sets",
      "noRecords": "No workout records.",
      "loadDetailError": "Could not load details.",
      "todayIs": "Today is",
      "runDay": "Let's go!",
      "startRoutine": "Start {{name}}"
    }
  },
  "workout": {
    "title": "Workout",
    "startEmpty": "Start Empty Workout",
    "recentRoutines": "Recent Routines",
    "noHistory": "No workout history yet.",
    "deleteWorkoutFailed": "Failed to delete workout.",
    "startWithRoutine": "Start with this Routine",
    "untitled": "Untitled Workout",
    "defaultName": "Workout",
    "workoutOn": "Workout on {{date}}",
    "resting": "Resting...",
    "tapAddExercise": "Tap below to add an exercise",
    "addExercise": "Add Exercise",
    "finish": "Finish",
    "cancelWorkout": "Cancel Workout?",
    "cancelProgressLost": "Current progress will be lost.",
    "continue": "Continue",
    "deleteExercise": "Delete Exercise?",
    "deleteExerciseConfirm": "Are you sure you want to remove \"{{name}}\"?",
    "deleteExerciseSub": "All sets for this exercise will be removed.",
    "set": "Set",
    "reps": "Reps",
    "done": "Done",
    "addSet": "Add Set",
    "addExerciseTitle": "Add Exercise",
    "searchPlaceholder": "Search exercises...",
    "createNew": "Create \"{{name}}\"",
    "suggestions": "Suggestions",
    "noExercises": "No exercises found. Type to create one.",
    "summaryComplete": "Workout Complete!",
    "summaryConfirmName": "Confirm name to save your workout.",
    "summaryWillSave": "Your workout will be saved.",
    "summaryNamePlaceholder": "e.g. Push Day",
    "time": "Time",
    "volume": "Volume",
    "sets": "Sets",
    "saveFinish": "Save & Finish",
    "saving": "Saving...",
    "cancel": "Cancel",
    "restingTitle": "Resting",
    "nextSet": "Next Set",
    "skip": "Skip",
    "loading": "Loading...",
    "exerciseList": "Exercise list",
    "saveError": "Failed to save workout.",
    "noRecordForDate": "No workout on this day.",
    "startSuffix": "start",
    "endSuffix": "end",
    "noSetRecords": "No set records.",
    "completed": "Completed"
  },
  "data": {
    "title": "Data",
    "exercise": "Exercise",
    "noExercises": "No exercises recorded yet.",
    "selectExercise": "Select an exercise",
    "view": "View",
    "chart": "Chart",
    "history": "History",
    "metric": "Metric",
    "maxWeight": "Max Weight",
    "maxVolume": "Max Volume",
    "totalVolume": "Total Volume",
    "totalSets": "Total Sets",
    "noChartData": "No workout data recorded yet.",
    "loadingHistory": "Loading history...",
    "noHistoryData": "No exercise history yet.",
    "set": "Set",
    "timesAgo": "{{n}} sessions ago",
    "totalKilos": "Total volume",
    "personalBest": "Personal Best (PR)",
    "totalRecords": "Total Records",
    "days": "days",
    "loadError": "Error loading analytics: {{message}}"
  },
  "workoutHistory": {
    "deleteTitle": "Delete Workout?",
    "deleteMessage": "Are you sure you want to remove \"{{name}}\" from your history?",
    "deleteSub": "Your exercise data will remain intact."
  },
  "profile": {
    "title": "Profile",
    "basicInfo": "Basic Info",
    "name": "Name",
    "namePlaceholder": "Enter name",
    "notSet": "Not set",
    "age": "Age",
    "agePlaceholder": "Enter age",
    "years": "years",
    "gender": "Gender",
    "male": "Male",
    "female": "Female",
    "other": "Other",
    "height": "Height (cm)",
    "heightPlaceholder": "Enter height",
    "weightRecords": "Weight Records",
    "add": "Add",
    "save": "Save",
    "currentWeight": "Current weight",
    "enterValidWeight": "Please enter a valid weight.",
    "weightPlaceholder": "Enter weight (kg)",
    "noWeightRecords": "No weight records yet.",
    "noWeightRecords30d": "No records in the last 30 days."
  },
  "settings": {
    "title": "Settings",
    "darkMode": "Dark mode",
    "light": "Light",
    "dark": "Dark",
    "system": "System",
    "language": "Language",
    "dataManagement": "Data management",
    "dataManagementDesc": "Export and delete data",
    "account": "Account",
    "accountDesc": "Sign out and account",
    "info": "Info",
    "infoDesc": "App version and info",
    "noWorkouts": "No workout records saved.",
    "totalVolume": "Total volume",
    "totalSets": "Total sets",
    "exerciseList": "Exercise list",
    "delete": "Delete",
    "deleteWorkoutTitle": "Delete workout?",
    "deleteWorkoutMessage": "Delete \"{{name}}\"?",
    "deleteFailed": "Delete failed.",
    "loginFailed": "Login failed.",
    "logoutFailed": "Logout failed.",
    "fullName": "Full name",
    "email": "Email",
    "signInGmail": "Sign in with Gmail",
    "signInPrompt": "Sign in to keep your data safe.",
    "signOut": "Sign out",
    "infoPlaceholder": "Coming soon.",
    "count": "{{n}} items"
  },
  "modals": {
    "splitCountTitle": "Split count",
    "splitCountDesc": "How many days in your split? (1–7)",
    "splitCountLabel": "Split count",
    "splitOption": "{{n}}-day",
    "saving": "Saving...",
    "next": "Next",
    "cancel": "Cancel",
    "weeklyGoalTitle": "Weekly goal",
    "weeklyGoalDesc": "Workouts per week (max 7)",
    "weeklyGoalLabel": "Weekly goal",
    "timesOption": "{{n}}",
    "save": "Save",
    "splitOrderTitle": "Split order",
    "splitOrderDesc": "Choose a program for each day",
    "selectWorkout": "Select workout",
    "noPrograms": "No workout programs saved. Save a workout first.",
    "confirm": "Confirm",
    "back": "Back",
    "splitSelectTitle": "Day {{n}}",
    "splitOrderSelectAll": "Select a workout for each day."
  },
  "common": {
    "delete": "Delete",
    "cancel": "Cancel",
    "deleteTitle": "Delete?",
    "save": "Save",
    "add": "Add"
  }
}



===== FILE: src\i18n\locales\ko.json =====
{
  "nav": {
    "home": "홈",
    "workout": "운동",
    "data": "데이터",
    "profile": "프로필"
  },
  "home": {
    "title": "홈",
    "weeklyGoal": {
      "setPrompt": "주간 목표를 설정하세요",
      "progress": "이번 주 목표 달성: {{current}} / {{goal}}회",
      "saveError": "목표 저장에 실패했습니다"
    },
    "split": {
      "setPrompt": "분할 운동을 설정하세요",
      "splitCount": "{{count}}분할 운동",
      "changeSplit": "분할 수 변경",
      "saveCountError": "분할 수 저장에 실패했습니다",
      "saveOrderError": "분할 순서 저장에 실패했습니다",
      "saveProgramFirst": "먼저 운동 프로그램을 저장해주세요."
    },
    "today": {
      "completed": "오늘 완료",
      "workout": "운동",
      "noSets": "완료된 세트 없음",
      "noRecords": "운동 기록이 없습니다.",
      "loadDetailError": "상세 기록을 불러오지 못했습니다.",
      "todayIs": "오늘은",
      "runDay": "달리는 날입니다!",
      "startRoutine": "{{name}} 루틴 시작하기"
    }
  },
  "workout": {
    "title": "운동",
    "startEmpty": "빈 운동 시작",
    "recentRoutines": "최근 루틴",
    "noHistory": "아직 운동 기록이 없습니다.",
    "deleteWorkoutFailed": "운동 삭제에 실패했습니다.",
    "startWithRoutine": "이 루틴으로 시작",
    "untitled": "제목 없음",
    "defaultName": "운동",
    "workoutOn": "{{date}} 운동",
    "resting": "휴식 중...",
    "tapAddExercise": "아래를 눌러 운동 추가",
    "addExercise": "운동 추가",
    "finish": "종료",
    "cancelWorkout": "운동 취소?",
    "cancelProgressLost": "진행 내용이 사라집니다.",
    "continue": "계속",
    "deleteExercise": "운동 삭제?",
    "deleteExerciseConfirm": "\"{{name}}\"을(를) 삭제하시겠습니까?",
    "deleteExerciseSub": "이 운동의 모든 세트가 삭제됩니다.",
    "set": "세트",
    "reps": "회",
    "done": "완료",
    "addSet": "세트 추가",
    "addExerciseTitle": "운동 추가",
    "searchPlaceholder": "운동 검색...",
    "createNew": "\"{{name}}\" 만들기",
    "suggestions": "추천",
    "noExercises": "운동이 없습니다. 입력하여 새로 만드세요.",
    "summaryComplete": "운동 완료!",
    "summaryConfirmName": "이름을 확인하고 저장하세요.",
    "summaryWillSave": "운동이 저장됩니다.",
    "summaryNamePlaceholder": "예: 푸시 데이",
    "time": "시간",
    "volume": "볼륨",
    "sets": "세트",
    "saveFinish": "저장 후 종료",
    "saving": "저장 중...",
    "cancel": "취소",
    "restingTitle": "휴식",
    "nextSet": "다음 세트",
    "skip": "건너뛰기",
    "loading": "로딩 중...",
    "exerciseList": "운동 목록",
    "saveError": "운동 저장에 실패했습니다.",
    "noRecordForDate": "이 날 운동 기록이 없습니다.",
    "startSuffix": "시작",
    "endSuffix": "종료",
    "noSetRecords": "세트 기록이 없습니다.",
    "completed": "운동 완료"
  },
  "data": {
    "title": "데이터",
    "exercise": "운동",
    "noExercises": "아직 기록된 운동이 없습니다",
    "selectExercise": "운동을 선택해 주세요",
    "view": "보기",
    "chart": "차트",
    "history": "이력",
    "metric": "지표",
    "maxWeight": "Max Weight",
    "maxVolume": "Max Volume",
    "totalVolume": "Total Volume",
    "totalSets": "Total Sets",
    "noChartData": "아직 기록된 운동 데이터가 없습니다.",
    "loadingHistory": "이력을 불러오는 중...",
    "noHistoryData": "아직 기록된 운동 이력이 없습니다.",
    "set": "세트",
    "timesAgo": "{{n}}회 전",
    "totalKilos": "총 키로수",
    "personalBest": "Personal Best (PR)",
    "totalRecords": "Total Records",
    "days": "일",
    "loadError": "Error loading analytics: {{message}}"
  },
  "workoutHistory": {
    "deleteTitle": "운동 기록 삭제?",
    "deleteMessage": "히스토리에서 \"{{name}}\"을(를) 삭제하시겠습니까?",
    "deleteSub": "운동 데이터는 유지됩니다."
  },
  "profile": {
    "title": "프로필",
    "basicInfo": "기본 정보",
    "name": "이름",
    "namePlaceholder": "이름을 입력하세요",
    "notSet": "미설정",
    "age": "나이",
    "agePlaceholder": "나이를 입력하세요",
    "years": "세",
    "gender": "성별",
    "male": "남성",
    "female": "여성",
    "other": "기타",
    "height": "키 (cm)",
    "heightPlaceholder": "키를 입력하세요",
    "weightRecords": "몸무게 기록",
    "add": "추가",
    "save": "저장",
    "currentWeight": "현재 몸무게",
    "enterValidWeight": "올바른 몸무게를 입력해주세요.",
    "weightPlaceholder": "몸무게를 입력하세요 (kg)",
    "noWeightRecords": "아직 몸무게 기록이 없습니다.",
    "noWeightRecords30d": "최근 30일 내 기록이 없습니다."
  },
  "settings": {
    "title": "설정",
    "darkMode": "다크모드",
    "light": "라이트",
    "dark": "다크",
    "system": "시스템",
    "language": "언어",
    "dataManagement": "데이터 관리",
    "dataManagementDesc": "데이터 내보내기 및 삭제",
    "account": "계정",
    "accountDesc": "로그아웃 및 계정 관리",
    "info": "정보",
    "infoDesc": "앱 버전 및 정보",
    "noWorkouts": "저장된 운동 기록이 없습니다.",
    "totalVolume": "총 볼륨",
    "totalSets": "총 세트",
    "exerciseList": "운동 목록",
    "delete": "삭제",
    "deleteWorkoutTitle": "운동 기록 삭제",
    "deleteWorkoutMessage": "\"{{name}}\" 기록을 삭제하시겠습니까?",
    "deleteFailed": "삭제에 실패했습니다.",
    "loginFailed": "로그인에 실패했습니다.",
    "logoutFailed": "로그아웃에 실패했습니다.",
    "fullName": "이름",
    "email": "이메일",
    "signInGmail": "Gmail로 로그인",
    "signInPrompt": "로그인하여 데이터를 안전하게 보관하세요.",
    "signOut": "로그아웃",
    "infoPlaceholder": "정보 섹션은 준비 중입니다.",
    "count": "{{n}}개"
  },
  "modals": {
    "splitCountTitle": "분할 수 설정",
    "splitCountDesc": "몇 분할로 운동하시겠습니까? (1-7분할)",
    "splitCountLabel": "분할 수",
    "splitOption": "{{n}}분할",
    "saving": "저장 중...",
    "next": "다음",
    "cancel": "취소",
    "weeklyGoalTitle": "주간 목표 설정",
    "weeklyGoalDesc": "주당 운동 횟수를 선택하세요 (최대 7회)",
    "weeklyGoalLabel": "주간 목표",
    "timesOption": "{{n}}회",
    "save": "저장",
    "splitOrderTitle": "분할 순서 설정",
    "splitOrderDesc": "각 분할에 운동 프로그램을 선택하세요",
    "selectWorkout": "운동 선택",
    "noPrograms": "저장된 운동 프로그램이 없습니다. 먼저 운동을 저장해주세요.",
    "confirm": "확인",
    "back": "뒤로",
    "splitSelectTitle": "{{n}}분할 운동 선택",
    "splitOrderSelectAll": "모든 분할에 운동을 선택해주세요."
  },
  "common": {
    "delete": "삭제",
    "cancel": "취소",
    "deleteTitle": "삭제?",
    "save": "저장",
    "add": "추가"
  }
}



===== FILE: src\lib\supabase.ts =====
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);



===== FILE: src\services\analytics.service.ts =====
import { supabase } from '@/lib/supabase';

export interface AnalyticsRow {
  exercise_name: string;
  date: string;
  max_weight: number;
  max_volume: number;
  total_volume: number;
}

/**
 * Fetch workout analytics using RPC function
 */
export async function getWorkoutAnalytics(): Promise<AnalyticsRow[]> {
  const { data, error } = await supabase.rpc('get_workout_analytics');

  if (error) throw error;
  return data || [];
}

/**
 * 특정 운동의 이력을 조회한다.
 * sets 중 is_completed === true 인 세트만 포함한다 (실제 수행 완료한 세트만).
 *
 * @param userId - 사용자 ID
 * @param exerciseName - 운동 이름
 * @param limit - 반환할 워크아웃 수 (기본 5, DB 조회는 20건)
 * @returns 워크아웃별 { workoutId, workoutDate, sets } (completed 세트만)
 */
export async function getExerciseHistory(
  userId: string,
  exerciseName: string,
  limit: number = 5
) {
  const { data: workoutsData, error } = await supabase
    .from('workouts')
    .select(`
      id,
      start_time,
      exercises (
        id,
        name,
        order,
        sets (
          id,
          weight,
          reps,
          order,
          is_completed
        )
      )
    `)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .order('start_time', { ascending: false })
    .limit(20);

  if (error) throw error;

  // 선택한 운동이 포함된 워크아웃만 남기고 limit 까지 자른다
  const filteredWorkouts = workoutsData
    ?.filter((workout: any) =>
      workout.exercises?.some((ex: any) => ex.name === exerciseName)
    )
    .slice(0, limit) || [];

  return filteredWorkouts
    .map((workout: any) => {
      const exercise = workout.exercises.find((e: any) => e.name === exerciseName);
      // is_completed === true 인 세트만 사용 (미완료·미체크는 제외)
      const completedSets = (exercise?.sets || []).filter((s: any) => s.is_completed === true);
      const sortedSets = completedSets.sort((a: any, b: any) => a.order - b.order);
      // 완료 세트가 하나도 없으면 이력에 포함하지 않음 (빈 컬럼 방지)
      if (sortedSets.length === 0) return null;
      return {
        workoutId: workout.id,
        workoutDate: workout.start_time,
        sets: sortedSets.map((set: any) => ({
          order: set.order,
          weight: set.weight,
          reps: set.reps,
        })),
      };
    })
    .filter((x): x is NonNullable<typeof x> => x != null);
}



===== FILE: src\services\home.service.ts =====
import { supabase } from '@/lib/supabase';

/**
 * Fetch weekly goal for a user
 */
export async function getWeeklyGoal(userId: string): Promise<number | null> {
  const { data, error } = await supabase
    .from('weekly_goals')
    .select('weekly_target')
    .eq('user_id', userId)
    .single();

  if (error && error.code !== 'PGRST116') {
    throw error;
  }

  return data?.weekly_target ?? null;
}

/**
 * Save weekly goal for a user
 */
export async function saveWeeklyGoal(userId: string, goal: number): Promise<void> {
  const { error } = await supabase
    .from('weekly_goals')
    .upsert(
      { user_id: userId, weekly_target: goal },
      { onConflict: 'user_id' }
    );

  if (error) throw error;
}

/**
 * Fetch split config for a user
 */
export async function getSplitConfig(userId: string) {
  const { data, error } = await supabase
    .from('split_config')
    .select('split_count, split_order')
    .eq('user_id', userId)
    .single();

  if (error && error.code !== 'PGRST116') {
    throw error;
  }

  return data
    ? {
        split_count: data.split_count,
        split_order: (data.split_order as string[]) ?? [],
      }
    : null;
}

/**
 * Save split count for a user
 */
export async function saveSplitCount(userId: string, count: number): Promise<void> {
  const { error } = await supabase
    .from('split_config')
    .upsert(
      { user_id: userId, split_count: count, split_order: [] },
      { onConflict: 'user_id' }
    );

  if (error) throw error;
}

/**
 * Save split order for a user
 */
export async function saveSplitOrder(userId: string, order: string[]): Promise<number> {
  const { data: currentConfig, error: fetchError } = await supabase
    .from('split_config')
    .select('split_count')
    .eq('user_id', userId)
    .single();

  if (fetchError || !currentConfig) {
    throw new Error('분할 수를 먼저 설정해주세요.');
  }

  const { error } = await supabase
    .from('split_config')
    .upsert(
      { user_id: userId, split_count: currentConfig.split_count, split_order: order },
      { onConflict: 'user_id' }
    );

  if (error) throw error;
  return currentConfig.split_count;
}

/** 홈/주간 스케줄·오늘 기록용 워크아웃 요약 */
export interface WorkoutSummary {
  id: string;
  start_time: string;
  end_time: string | null;
  name: string | null;
  total_weight: number;
  total_sets: number;
}

/**
 * Fetch all workouts (id, start_time, end_time, name, total_weight, total_sets) for a user
 */
export async function getAllWorkouts(userId: string): Promise<WorkoutSummary[]> {
  const { data, error } = await supabase
    .from('workouts')
    .select('id, start_time, end_time, name, total_weight, total_sets')
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .order('start_time', { ascending: false });

  if (error) throw error;
  return data ?? [];
}



===== FILE: src\services\index.ts =====
// Workout services
export {
  getWorkoutByName,
  getWorkoutById,
  getWorkoutsWithDetails,
  saveWorkout,
  deleteWorkout,
  getRecentWorkoutsWithExercises,
  getWorkoutForDate,
  getExerciseNames,
  type SaveWorkoutData,
} from './workout.service';

// Profile services
export {
  getProfile,
  upsertProfile,
  getWeightRecords,
  addWeightRecord,
} from './profile.service';

// Analytics services
export {
  getWorkoutAnalytics,
  getExerciseHistory,
  type AnalyticsRow,
} from './analytics.service';

// Home services
export {
  getWeeklyGoal,
  saveWeeklyGoal,
  getSplitConfig,
  saveSplitCount,
  saveSplitOrder,
  getAllWorkouts,
  type WorkoutSummary,
} from './home.service';



===== FILE: src\services\profile.service.ts =====
import { supabase } from '@/lib/supabase';
import { UserProfile, WeightRecord } from '@/types/profile';

/**
 * Fetch user profile
 */
export async function getProfile(userId: string): Promise<UserProfile | null> {
  const { data, error } = await supabase
    .from('user_profiles')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (error && error.code !== 'PGRST116') {
    throw error;
  }

  return data || null;
}

/**
 * Update or create user profile
 */
export async function upsertProfile(
  userId: string,
  updates: Partial<UserProfile>
): Promise<UserProfile> {
  const { data: existingProfile } = await supabase
    .from('user_profiles')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (existingProfile) {
    const { data, error } = await supabase
      .from('user_profiles')
      .update(updates)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;
    return data;
  } else {
    const { data, error } = await supabase
      .from('user_profiles')
      .insert({
        user_id: userId,
        ...updates,
      })
      .select()
      .single();

    if (error) throw error;
    return data;
  }
}

/**
 * Fetch weight records for a user
 */
export async function getWeightRecords(
  userId: string,
  limit: number = 100
): Promise<WeightRecord[]> {
  const { data, error } = await supabase
    .from('weight_records')
    .select('*')
    .eq('user_id', userId)
    .order('recorded_at', { ascending: false })
    .limit(limit);

  if (error) throw error;
  return data || [];
}

/**
 * Add or update weight record for a specific date
 */
export async function addWeightRecord(
  userId: string,
  weight: number,
  recordedAt?: string
): Promise<WeightRecord> {
  const recordDate = recordedAt || new Date().toISOString();
  const recordDateTime = new Date(recordDate);
  const dateOnly = recordDateTime.toISOString().split('T')[0];

  const startOfDay = `${dateOnly}T00:00:00.000Z`;
  const endOfDay = `${dateOnly}T23:59:59.999Z`;

  // Find existing records for the same date
  const { data: existingRecords, error: checkError } = await supabase
    .from('weight_records')
    .select('id')
    .eq('user_id', userId)
    .gte('recorded_at', startOfDay)
    .lte('recorded_at', endOfDay);

  if (checkError) throw checkError;

  // Delete existing records for the same date
  if (existingRecords && existingRecords.length > 0) {
    const recordIds = existingRecords.map((r) => r.id);
    const { error: deleteError } = await supabase
      .from('weight_records')
      .delete()
      .in('id', recordIds);

    if (deleteError) throw deleteError;
  }

  // Insert new record
  const { data, error } = await supabase
    .from('weight_records')
    .insert({
      user_id: userId,
      weight,
      recorded_at: recordDate,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}



===== FILE: src\services\workout.service.ts =====
import { supabase } from '@/lib/supabase';
import { WorkoutWithDetails } from '@/types/workout';

export interface SaveWorkoutData {
  id: string;
  userId: string;
  name: string;
  startTime: string;
  endTime: string;
  totalWeight: number;
  totalSets: number;
  exercises: Array<{
    id: string;
    name: string;
    sets: Array<{
      id: string;
      weight: number;
      reps: number;
      isCompleted: boolean;
    }>;
  }>;
}

/**
 * Fetch workout by name for a user
 */
export async function getWorkoutByName(
  userId: string,
  workoutName: string
): Promise<WorkoutWithDetails | null> {
  const { data, error } = await supabase
    .from('workouts')
    .select(`
      *,
      exercises (
        *,
        sets (*)
      )
    `)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .eq('name', workoutName)
    .order('start_time', { ascending: false })
    .limit(1);

  if (error) throw error;

  if (data && data.length > 0) {
    const workout = data[0] as any;
    return {
      ...workout,
      exercises: workout.exercises
        .sort((a: any, b: any) => a.order - b.order)
        .map((e: any) => ({
          ...e,
          sets: e.sets.sort((a: any, b: any) => a.order - b.order),
        })),
    };
  }

  return null;
}

/**
 * Fetch a single workout by id with exercises and sets
 */
export async function getWorkoutById(
  userId: string,
  workoutId: string
): Promise<WorkoutWithDetails | null> {
  const { data, error } = await supabase
    .from('workouts')
    .select(`
      *,
      exercises (
        *,
        sets (*)
      )
    `)
    .eq('id', workoutId)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .single();

  if (error || !data) return null;

  const w = data as any;
  return {
    ...w,
    exercises: (w.exercises || [])
      .sort((a: any, b: any) => a.order - b.order)
      .map((e: any) => ({
        ...e,
        sets: (e.sets || []).sort((a: any, b: any) => a.order - b.order),
      })),
  };
}

/**
 * Fetch all workouts with details for a user
 */
export async function getWorkoutsWithDetails(
  userId: string
): Promise<WorkoutWithDetails[]> {
  const { data, error } = await supabase
    .from('workouts')
    .select(`
      *,
      exercises (
        *,
        sets (*)
      )
    `)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .order('start_time', { ascending: false });

  if (error) throw error;

  if (data) {
    return data.map((w: any) => ({
      ...w,
      exercises: w.exercises
        .sort((a: any, b: any) => a.order - b.order)
        .map((e: any) => ({
          ...e,
          sets: e.sets.sort((a: any, b: any) => a.order - b.order),
        })),
    }));
  }

  return [];
}

/**
 * Save a complete workout with exercises and sets
 */
export async function saveWorkout(data: SaveWorkoutData): Promise<void> {
  const { error: workoutError } = await supabase.from('workouts').insert({
    id: data.id,
    user_id: data.userId,
    name: data.name,
    start_time: data.startTime,
    end_time: data.endTime,
    total_weight: data.totalWeight,
    total_sets: data.totalSets,
  });

  if (workoutError) throw workoutError;

  for (let i = 0; i < data.exercises.length; i++) {
    const ex = data.exercises[i];

    const { error: exError } = await supabase.from('exercises').insert({
      id: ex.id,
      workout_id: data.id,
      user_id: data.userId,
      name: ex.name,
      order: i,
    });

    if (exError) throw exError;

    const setsToInsert = ex.sets.map((set, setIndex) => ({
      id: set.id,
      exercise_id: ex.id,
      user_id: data.userId,
      weight: set.weight,
      reps: set.reps,
      is_completed: set.isCompleted,
      order: setIndex,
    }));

    if (setsToInsert.length > 0) {
      const { error: setsError } = await supabase.from('sets').insert(setsToInsert);
      if (setsError) throw setsError;
    }
  }
}

/**
 * Soft delete a workout
 */
export async function deleteWorkout(workoutId: string): Promise<void> {
  const { error } = await supabase
    .from('workouts')
    .update({ is_disabled: true })
    .eq('id', workoutId);

  if (error) throw error;
}

/**
 * Get recent workouts with exercises for loading previous sets
 */
export async function getRecentWorkoutsWithExercises(
  userId: string,
  limit: number = 20
) {
  const { data, error } = await supabase
    .from('workouts')
    .select(`
      id,
      start_time,
      exercises (
        id,
        name,
        order,
        sets (
          weight,
          reps,
          order
        )
      )
    `)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .order('start_time', { ascending: false })
    .limit(limit);

  if (error) throw error;
  return data || [];
}

/**
 * Get workout for a specific date
 */
export async function getWorkoutForDate(
  userId: string,
  date: Date
): Promise<WorkoutWithDetails | null> {
  const startOfDay = new Date(date);
  startOfDay.setHours(0, 0, 0, 0);
  const endOfDay = new Date(date);
  endOfDay.setHours(23, 59, 59, 999);

  const { data, error } = await supabase
    .from('workouts')
    .select(`
      *,
      exercises (
        *,
        sets (*)
      )
    `)
    .eq('user_id', userId)
    .eq('is_disabled', false)
    .gte('start_time', startOfDay.toISOString())
    .lte('start_time', endOfDay.toISOString())
    .order('start_time', { ascending: false })
    .limit(1);

  if (error) throw error;

  if (data && data.length > 0) {
    const workout = data[0] as any;
    return {
      ...workout,
      exercises: workout.exercises
        .sort((a: any, b: any) => a.order - b.order)
        .map((e: any) => ({
          ...e,
          sets: e.sets.sort((a: any, b: any) => a.order - b.order),
        })),
    };
  }

  return null;
}

/**
 * Get unique exercise names for a user
 */
export async function getExerciseNames(userId: string): Promise<string[]> {
  const { data, error } = await supabase
    .from('exercises')
    .select(`
      name,
      workouts!left (
        is_disabled
      )
    `)
    .eq('user_id', userId);

  if (error) throw error;

  if (data) {
    const filtered = data.filter((row: any) => {
      const workout = row.workouts as { is_disabled: boolean } | null | undefined;
      return workout == null || workout.is_disabled === false;
    });

    const nameSet = new Set<string>();
    filtered.forEach((row: any) => {
      if (row.name) {
        nameSet.add(row.name);
      }
    });

    return Array.from(nameSet).sort();
  }

  return [];
}



===== FILE: src\stores\index.ts =====
// User
export { useUserStore } from './useUserStore';

// Home
export { useHomeDataStore } from './useHomeDataStore';

// Workout
export { useWorkoutHistoryStore } from './useWorkoutHistoryStore';
export { useWorkoutAnalyticsStore } from './useWorkoutAnalyticsStore';
export type { DateAnalytics, WorkoutAnalyticsData } from './useWorkoutAnalyticsStore';

// Exercise
export { useExerciseHistoryStore } from './useExerciseHistoryStore';
export type { ExerciseSetHistory, ExerciseHistoryByWorkout } from './useExerciseHistoryStore';

// Profile
export { useProfileStore } from './useProfileStore';

// Settings
export { useSettingsStore } from './useSettingsStore';
export type { ThemeMode } from './useSettingsStore';



===== FILE: src\stores\useExerciseHistoryStore.ts =====
import { create } from 'zustand';
import { useUserStore } from './useUserStore';
import { getExerciseHistory } from '@/services';

export interface ExerciseSetHistory {
  workoutId: string;
  workoutDate: string;
  setOrder: number;
  weight: number;
  reps: number;
}

export interface ExerciseHistoryByWorkout {
  workoutId: string;
  workoutDate: string;
  sets: Array<{
    order: number;
    weight: number;
    reps: number;
  }>;
}

interface ExerciseHistoryStore {
  exerciseHistory: ExerciseHistoryByWorkout[];
  historyCache: Map<string, ExerciseHistoryByWorkout[]>;
  currentExercise: string | null;
  isLoading: boolean;
  error: Error | null;
  fetchExerciseHistory: (exerciseName: string) => Promise<void>;
  clearHistory: () => void;
  clearCache: () => void;
}

export const useExerciseHistoryStore = create<ExerciseHistoryStore>((set, get) => {
  if (typeof window !== 'undefined') {
    const handleWorkoutChange = () => {
      get().clearCache();
    };

    window.addEventListener('workoutSaved', handleWorkoutChange);
    window.addEventListener('workoutDeleted', handleWorkoutChange);
  }

  return {
    exerciseHistory: [],
    historyCache: new Map(),
    currentExercise: null,
    isLoading: false,
    error: null,

    fetchExerciseHistory: async (exerciseName: string) => {
      const { historyCache, currentExercise } = get();

      if (currentExercise === exerciseName && historyCache.has(exerciseName)) {
        const cachedData = historyCache.get(exerciseName)!;
        set({ exerciseHistory: cachedData, isLoading: false });
        return;
      }

      if (historyCache.has(exerciseName)) {
        const cachedData = historyCache.get(exerciseName)!;
        set({ exerciseHistory: cachedData, currentExercise: exerciseName, isLoading: false });
        return;
      }

      try {
        set({ isLoading: true, error: null, currentExercise: exerciseName });

        const userId = await useUserStore.getState().getUserId();
        const history = await getExerciseHistory(userId, exerciseName);

        const newCache = new Map(historyCache);
        newCache.set(exerciseName, history);
        set({
          exerciseHistory: history,
          historyCache: newCache,
          isLoading: false,
        });
      } catch (err) {
        console.error('Error fetching exercise history:', err);
        set({
          error: err instanceof Error ? err : new Error('Failed to fetch exercise history'),
          isLoading: false,
        });
      }
    },

    clearHistory: () => {
      set({ exerciseHistory: [], currentExercise: null, error: null });
    },

    clearCache: () => {
      // Only clear cache, keep current display data
      set({ historyCache: new Map() });
    },
  };
});



===== FILE: src\stores\useHomeDataStore.ts =====
import { create } from 'zustand';
import { useUserStore } from './useUserStore';
import { getTodayDateString, isCacheValid, getWeekRange, getTodayRange } from '@/utils';
import { getWeeklyGoal, getSplitConfig, getAllWorkouts, getWorkoutById, type WorkoutSummary } from '@/services';
import type { WorkoutWithDetails } from '@/types/workout';

interface HomeData {
  weeklyGoal: number | null;
  splitConfig: {
    split_count: number;
    split_order: string[];
  } | null;
  workoutNames: string[];
  weekWorkouts: WorkoutSummary[];
  allWorkouts: WorkoutSummary[];
  todayWorkout: WorkoutSummary | null;
  todayWorkoutDetail: WorkoutWithDetails | null;
  cachedDate: string;
}

interface HomeDataStore {
  homeData: HomeData | null;
  isLoading: boolean;
  fetchHomeData: (forceRefresh?: boolean) => Promise<void>;
  refreshHomeData: () => Promise<void>;
  clearHomeData: () => void;
}

export const useHomeDataStore = create<HomeDataStore>((set, get) => {
  let cachedUserId: string | null = null;

  if (typeof window !== 'undefined') {
    const handleDataChange = () => {
      get().refreshHomeData();
    };

    window.addEventListener('workoutSaved', handleDataChange);
    window.addEventListener('homeDataChanged', handleDataChange);

    setInterval(() => {
      const { homeData } = get();
      if (homeData && !isCacheValid(homeData.cachedDate)) {
        get().refreshHomeData();
      }
    }, 60000);
  }

  return {
    homeData: null,
    isLoading: true,

    fetchHomeData: async (forceRefresh = false) => {
      const { homeData } = get();
      const userId = await useUserStore.getState().getUserId();

      // Skip if cache is valid and not forcing refresh
      if (!forceRefresh && homeData && isCacheValid(homeData.cachedDate) && cachedUserId === userId) {
        set({ isLoading: false });
        return;
      }

      cachedUserId = userId;

      try {
        // Only show loading if no existing data
        if (!homeData) {
          set({ isLoading: true });
        }

        const { start: weekStart, end: weekEnd } = getWeekRange();
        const { start: todayStart, end: todayEnd } = getTodayRange();

        const [weeklyGoal, splitConfig, allWorkouts] = await Promise.all([
          getWeeklyGoal(userId).catch(() => null),
          getSplitConfig(userId).catch(() => null),
          getAllWorkouts(userId),
        ]);

        const weekWorkouts = allWorkouts.filter((w) => {
          const workoutTime = new Date(w.start_time);
          return workoutTime >= new Date(weekStart) && workoutTime <= new Date(weekEnd);
        });

        const todayWorkout = allWorkouts.find((w) => {
          const workoutTime = new Date(w.start_time);
          return workoutTime >= new Date(todayStart) && workoutTime < new Date(todayEnd);
        }) ?? null;

        let todayWorkoutDetail: WorkoutWithDetails | null = null;
        if (todayWorkout) {
          todayWorkoutDetail = await getWorkoutById(userId, todayWorkout.id).catch(() => null);
        }

        const workoutNames = Array.from(
          new Set(allWorkouts.map((w) => w.name).filter(Boolean) as string[])
        );

        const data: HomeData = {
          weeklyGoal,
          splitConfig,
          workoutNames,
          weekWorkouts,
          allWorkouts,
          todayWorkout,
          todayWorkoutDetail,
          cachedDate: getTodayDateString(),
        };

        set({ homeData: data, isLoading: false });
      } catch (error) {
        console.error("Error fetching home data:", error);
        set({ isLoading: false });
      }
    },

    refreshHomeData: async () => {
      cachedUserId = null;
      // Don't clear existing data - fetch in background
      await get().fetchHomeData(true);
    },

    clearHomeData: () => {
      cachedUserId = null;
      set({ homeData: null, isLoading: false });
    },
  };
});



===== FILE: src\stores\useProfileStore.ts =====
import { create } from 'zustand';
import { UserProfile, WeightRecord } from '@/types/profile';
import { useUserStore } from './useUserStore';
import {
  getProfile,
  upsertProfile,
  getWeightRecords,
  addWeightRecord as addWeightRecordService,
} from '@/services';

interface ProfileStore {
  profile: UserProfile | null;
  weightRecords: WeightRecord[];
  isLoading: boolean;
  isSaving: boolean;
  error: Error | null;
  isProfileLoaded: boolean;
  isWeightRecordsLoaded: boolean;
  fetchProfile: () => Promise<void>;
  updateProfile: (updates: Partial<UserProfile>) => Promise<void>;
  fetchWeightRecords: (force?: boolean) => Promise<void>;
  addWeightRecord: (weight: number, recordedAt?: string) => Promise<void>;
  refreshProfile: () => Promise<void>;
  clearProfile: () => void;
}

export const useProfileStore = create<ProfileStore>((set, get) => {
  let cachedProfileUserId: string | null = null;
  let cachedWeightRecordsUserId: string | null = null;

  return {
    profile: null,
    weightRecords: [],
    isLoading: false,
    isSaving: false,
    error: null,
    isProfileLoaded: false,
    isWeightRecordsLoaded: false,

    fetchProfile: async () => {
      const { profile, isProfileLoaded } = get();
      const userId = await useUserStore.getState().getUserId();

      if (isProfileLoaded && profile !== null && cachedProfileUserId === userId) {
        set({ isLoading: false });
        return;
      }

      if (isProfileLoaded && cachedProfileUserId === userId) {
        set({ isLoading: false });
        return;
      }

      cachedProfileUserId = userId;

      try {
        set({ isLoading: true, error: null });
        const data = await getProfile(userId);
        set({ profile: data, isLoading: false, isProfileLoaded: true });
      } catch (error) {
        console.error("Error fetching profile:", error);
        set({ error: error as Error, isLoading: false, isProfileLoaded: true });
      }
    },

    updateProfile: async (updates: Partial<UserProfile>) => {
      try {
        set({ isSaving: true, error: null });
        const userId = await useUserStore.getState().getUserId();
        const data = await upsertProfile(userId, updates);
        set({ profile: data, isSaving: false });
      } catch (error) {
        console.error("Error updating profile:", error);
        set({ error: error as Error, isSaving: false });
      }
    },

    fetchWeightRecords: async (force = false) => {
      const { weightRecords, isWeightRecordsLoaded } = get();
      const userId = await useUserStore.getState().getUserId();

      if (!force && isWeightRecordsLoaded && weightRecords.length > 0 && cachedWeightRecordsUserId === userId) {
        set({ isLoading: false });
        return;
      }

      if (!force && isWeightRecordsLoaded && cachedWeightRecordsUserId === userId) {
        set({ isLoading: false });
        return;
      }

      cachedWeightRecordsUserId = userId;

      try {
        set({ isLoading: true, error: null });
        const data = await getWeightRecords(userId);
        set({ weightRecords: data, isLoading: false, isWeightRecordsLoaded: true });
      } catch (error) {
        console.error("Error fetching weight records:", error);
        set({ error: error as Error, isLoading: false, isWeightRecordsLoaded: true });
      }
    },

    addWeightRecord: async (weight: number, recordedAt?: string) => {
      try {
        set({ isSaving: true, error: null });
        const userId = await useUserStore.getState().getUserId();
        await addWeightRecordService(userId, weight, recordedAt);
        await get().fetchWeightRecords(true);
        set({ isSaving: false });
      } catch (error) {
        console.error("Error adding weight record:", error);
        set({ error: error as Error, isSaving: false });
      }
    },

    refreshProfile: async () => {
      await Promise.all([
        get().fetchProfile(),
        get().fetchWeightRecords(true),
      ]);
    },

    clearProfile: () => {
      cachedProfileUserId = null;
      cachedWeightRecordsUserId = null;
      set({
        profile: null,
        weightRecords: [],
        isLoading: false,
        isSaving: false,
        error: null,
        isProfileLoaded: false,
        isWeightRecordsLoaded: false,
      });
    },
  };
});



===== FILE: src\stores\useSettingsStore.ts =====
import { create } from 'zustand';

export type ThemeMode = 'light' | 'dark' | 'system';
export type Language = 'ko' | 'en';

interface AppSettings {
  theme: ThemeMode;
  language: Language;
}

interface SettingsStore extends AppSettings {
  setTheme: (theme: ThemeMode) => void;
  setLanguage: (language: Language) => void;
  getEffectiveTheme: () => 'light' | 'dark';
  loadSettings: () => void;
}

const STORAGE_KEY = 'app-settings';

const getStoredSettings = (): Partial<AppSettings> => {
  if (typeof window === 'undefined') return {};
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
};

const saveSettings = (settings: Partial<AppSettings>) => {
  if (typeof window === 'undefined') return;
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  } catch {
    // Ignore storage errors
  }
};

export const useSettingsStore = create<SettingsStore>((set, get) => ({
  theme: 'system',
  language: 'en',

  loadSettings: () => {
    const stored = getStoredSettings();
    const theme = (stored.theme || 'system') as ThemeMode;
    const language = (stored.language || 'en') as Language;
    
    set({ theme, language });
    
    // Apply theme immediately
    if (typeof window !== 'undefined') {
      const effectiveTheme = theme === 'system' 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : theme;
      document.documentElement.classList.toggle('dark', effectiveTheme === 'dark');
    }
  },

  setTheme: (theme: ThemeMode) => {
    set({ theme });
    saveSettings({ theme, language: get().language });
    
    // Apply theme immediately
    if (typeof window !== 'undefined') {
      const effectiveTheme = theme === 'system' 
        ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        : theme;
      document.documentElement.classList.toggle('dark', effectiveTheme === 'dark');
    }
  },

  setLanguage: (language: Language) => {
    set({ language });
    saveSettings({ theme: get().theme, language });
  },

  getEffectiveTheme: () => {
    const { theme } = get();
    if (theme === 'system' && typeof window !== 'undefined') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    return theme as 'light' | 'dark';
  },
}));

// Initialize theme on mount
if (typeof window !== 'undefined') {
  const store = useSettingsStore.getState();
  store.loadSettings();

  // Listen for system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    const currentTheme = useSettingsStore.getState().theme;
    if (currentTheme === 'system') {
      document.documentElement.classList.toggle('dark', e.matches);
    }
  });
}



===== FILE: src\stores\useUserStore.ts =====
import { create } from 'zustand';
import { supabase } from '@/lib/supabase';

interface UserStore {
  userId: string | null;
  isLoading: boolean;
  initializeUser: () => Promise<void>;
  getUserId: () => Promise<string>;
  clearUser: () => void;
}

let userIdPromise: Promise<string> | null = null;

export const useUserStore = create<UserStore>((set, get) => ({
  userId: null,
  isLoading: true,

  initializeUser: async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      const userId = user?.id || "anon_user";
      set({ userId, isLoading: false });
      userIdPromise = Promise.resolve(userId);
    } catch (error) {
      console.error('Error initializing user:', error);
      set({ userId: "anon_user", isLoading: false });
      userIdPromise = Promise.resolve("anon_user");
    }
  },

  getUserId: async () => {
    const { userId } = get();
    
    // If we have cached user ID, return it immediately
    if (userId !== null) {
      return userId;
    }

    // If there's already a pending request, wait for it
    if (userIdPromise) {
      return userIdPromise;
    }

    // Create new request
    userIdPromise = (async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        const id = user?.id || "anon_user";
        set({ userId: id, isLoading: false });
        return id;
      } catch (error) {
        console.error('Error getting user ID:', error);
        const id = "anon_user";
        set({ userId: id, isLoading: false });
        return id;
      } finally {
        userIdPromise = null;
      }
    })();

    return userIdPromise;
  },

  clearUser: () => {
    userIdPromise = null;
    set({ userId: null, isLoading: true });
  },
}));

// Initialize user on module load
if (typeof window !== 'undefined') {
  useUserStore.getState().initializeUser();

  // Listen for auth state changes
  supabase.auth.onAuthStateChange((_event, session) => {
    const userId = session?.user?.id || "anon_user";
    useUserStore.setState({ userId, isLoading: false });
    userIdPromise = Promise.resolve(userId);
  });
}



===== FILE: src\stores\useWorkoutAnalyticsStore.ts =====
import { create } from 'zustand';
import { useUserStore } from './useUserStore';
import { getWorkoutAnalytics, type AnalyticsRow } from '@/services';

export interface DateAnalytics {
  date: string;
  maxWeight: number;
  maxVolume: number;
  totalVolume: number;
}

export interface WorkoutAnalyticsData {
  [exerciseName: string]: DateAnalytics[];
}

interface WorkoutAnalyticsStore {
  data: WorkoutAnalyticsData;
  isLoading: boolean;
  error: Error | null;
  isLoaded: boolean;
  fetchAnalytics: (forceRefresh?: boolean) => Promise<void>;
  refreshAnalytics: () => Promise<void>;
  clearAnalytics: () => void;
}

export const useWorkoutAnalyticsStore = create<WorkoutAnalyticsStore>((set, get) => {
  let cachedUserId: string | null = null;

  if (typeof window !== 'undefined') {
    const handleWorkoutChange = () => {
      get().refreshAnalytics();
    };

    window.addEventListener('workoutSaved', handleWorkoutChange);
    window.addEventListener('workoutDeleted', handleWorkoutChange);
  }

  return {
    data: {},
    isLoading: true,
    error: null,
    isLoaded: false,

    fetchAnalytics: async (forceRefresh = false) => {
      const { data, isLoaded } = get();
      const userId = await useUserStore.getState().getUserId();

      // Skip if already loaded and not forcing refresh
      if (!forceRefresh && isLoaded && cachedUserId === userId) {
        set({ isLoading: false });
        return;
      }

      cachedUserId = userId;

      try {
        // Only show loading if no existing data
        if (Object.keys(data).length === 0) {
          set({ isLoading: true, error: null });
        }

        const analyticsData = await getWorkoutAnalytics();

        if (!analyticsData || analyticsData.length === 0) {
          set({ data: {}, isLoading: false, isLoaded: true });
          return;
        }

        const analyticsMap: WorkoutAnalyticsData = {};

        analyticsData.forEach((row: AnalyticsRow) => {
          const exerciseName = row.exercise_name;
          const date = row.date.split('T')[0];

          if (!analyticsMap[exerciseName]) {
            analyticsMap[exerciseName] = [];
          }

          analyticsMap[exerciseName].push({
            date,
            maxWeight: Number(row.max_weight),
            maxVolume: Number(row.max_volume),
            totalVolume: Number(row.total_volume),
          });
        });

        Object.keys(analyticsMap).forEach((exerciseName) => {
          analyticsMap[exerciseName].sort((a, b) => a.date.localeCompare(b.date));
        });

        set({ data: analyticsMap, isLoading: false, isLoaded: true });
      } catch (err) {
        console.error('Error fetching workout analytics:', err);
        set({
          error: err instanceof Error ? err : new Error('Failed to fetch analytics'),
          isLoading: false,
          isLoaded: true,
        });
      }
    },

    refreshAnalytics: async () => {
      cachedUserId = null;
      // Don't clear existing data - fetch in background
      await get().fetchAnalytics(true);
    },

    clearAnalytics: () => {
      cachedUserId = null;
      set({ data: {}, isLoading: false, error: null, isLoaded: false });
    },
  };
});



===== FILE: src\stores\useWorkoutHistoryStore.ts =====
import { create } from 'zustand';
import { WorkoutWithDetails } from '@/types/workout';
import { useUserStore } from './useUserStore';
import { getWorkoutsWithDetails } from '@/services';

interface WorkoutHistoryStore {
  historyWorkouts: WorkoutWithDetails[];
  isLoading: boolean;
  isLoaded: boolean;
  fetchWorkoutHistory: (forceRefresh?: boolean) => Promise<void>;
  refreshWorkoutHistory: () => Promise<void>;
  clearWorkoutHistory: () => void;
}

export const useWorkoutHistoryStore = create<WorkoutHistoryStore>((set, get) => {
  let cachedUserId: string | null = null;

  if (typeof window !== 'undefined') {
    const handleWorkoutChange = () => {
      get().refreshWorkoutHistory();
    };

    window.addEventListener('workoutSaved', handleWorkoutChange);
    window.addEventListener('workoutDeleted', handleWorkoutChange);
  }

  return {
    historyWorkouts: [],
    isLoading: true,
    isLoaded: false,

    fetchWorkoutHistory: async (forceRefresh = false) => {
      const { historyWorkouts, isLoaded } = get();
      const userId = await useUserStore.getState().getUserId();

      // Skip if already loaded and not forcing refresh
      if (!forceRefresh && isLoaded && cachedUserId === userId) {
        set({ isLoading: false });
        return;
      }

      cachedUserId = userId;

      try {
        // Only show loading if no existing data
        if (historyWorkouts.length === 0) {
          set({ isLoading: true });
        }

        const workouts = await getWorkoutsWithDetails(userId);

        const uniqueWorkoutsMap = new Map<string, WorkoutWithDetails>();
        workouts.forEach((workout) => {
          const nameKey = workout.name ? workout.name.trim() : "Untitled";
          if (!uniqueWorkoutsMap.has(nameKey)) {
            uniqueWorkoutsMap.set(nameKey, workout);
          }
        });

        set({
          historyWorkouts: Array.from(uniqueWorkoutsMap.values()),
          isLoading: false,
          isLoaded: true,
        });
      } catch (error) {
        console.error("Error fetching workout history:", error);
        set({ isLoading: false, isLoaded: true });
      }
    },

    refreshWorkoutHistory: async () => {
      cachedUserId = null;
      // Don't clear existing data - fetch in background
      await get().fetchWorkoutHistory(true);
    },

    clearWorkoutHistory: () => {
      cachedUserId = null;
      set({ historyWorkouts: [], isLoading: false, isLoaded: false });
    },
  };
});



===== FILE: src\types\analytics.ts =====
export interface DateAnalytics {
  date: string; // YYYY-MM-DD format
  maxWeight: number;
  maxVolume: number;
  totalVolume: number;
}

export interface WorkoutAnalyticsData {
  [exerciseName: string]: DateAnalytics[];
}

export interface ExerciseSetHistory {
  workoutId: string;
  workoutDate: string;
  setOrder: number;
  weight: number;
  reps: number;
}

export interface ExerciseHistoryByWorkout {
  workoutId: string;
  workoutDate: string;
  sets: Array<{
    order: number;
    weight: number;
    reps: number;
  }>;
}



===== FILE: src\types\index.ts =====
// Workout types
export type {
  Workout,
  Exercise,
  Set,
  WorkoutWithDetails,
} from './workout';

// Profile types
export type {
  UserProfile,
  WeightRecord,
} from './profile';

// Analytics types
export type {
  DateAnalytics,
  WorkoutAnalyticsData,
  ExerciseSetHistory,
  ExerciseHistoryByWorkout,
} from './analytics';



===== FILE: src\types\profile.ts =====
export interface UserProfile {
  id: string;
  user_id: string;
  name: string | null;
  age: number | null;
  gender: 'male' | 'female' | 'other' | null;
  height: number | null;
  created_at: string;
  updated_at: string;
}

export interface WeightRecord {
  id: string;
  user_id: string;
  weight: number;
  recorded_at: string;
  created_at: string;
}



===== FILE: src\types\workout.ts =====
export interface Workout {
  id: string;
  name: string;
  start_time: string;
  end_time: string | null;
  total_weight: number;
  total_sets: number;
  user_id: string;
  is_disabled?: boolean;
}

export interface Exercise {
  id: string;
  workout_id: string;
  name: string;
  order: number;
}

export interface Set {
  id: string;
  exercise_id: string;
  weight: number;
  reps: number;
  is_completed: boolean;
  order: number;
}

export interface WorkoutWithDetails extends Workout {
  exercises: (Exercise & {
    sets: Set[];
  })[];
}



===== FILE: src\utils\date.ts =====
import {
  format,
  parseISO,
  startOfWeek,
  endOfWeek,
  startOfDay,
  addDays,
  eachDayOfInterval,
} from 'date-fns';
import { ko } from 'date-fns/locale';
import { enUS } from 'date-fns/locale';

export type DateLocale = 'en' | 'ko';

/**
 * Get today's date in YYYY-MM-DD format
 */
export const getTodayDateString = (): string => {
  return format(new Date(), 'yyyy-MM-dd');
};

/**
 * Get start and end of current week (Monday to Sunday)
 */
export const getWeekRange = (): { start: string; end: string } => {
  const now = new Date();
  const monday = startOfWeek(now, { weekStartsOn: 1 });
  const sunday = endOfWeek(now, { weekStartsOn: 1 });
  return { start: monday.toISOString(), end: sunday.toISOString() };
};

/**
 * Get today's date range (start of today to start of tomorrow)
 */
export const getTodayRange = (): { start: string; end: string } => {
  const today = startOfDay(new Date());
  const tomorrow = addDays(today, 1);
  return { start: today.toISOString(), end: tomorrow.toISOString() };
};

/**
 * Get all days of the current week (Monday to Sunday)
 */
export const getWeekDays = (): Date[] => {
  const now = new Date();
  const monday = startOfWeek(now, { weekStartsOn: 1 });
  const sunday = endOfWeek(now, { weekStartsOn: 1 });
  return eachDayOfInterval({ start: monday, end: sunday });
};

/**
 * Get short day label (locale-aware)
 */
export const getDayLabel = (date: Date, lang: DateLocale = 'en'): string => {
  return format(date, 'EEEEE', { locale: lang === 'ko' ? ko : enUS });
};

/**
 * Format date long e.g. "Dec 25, 2024 (Wed)" or "2024년 12월 25일 (수)"
 */
export const formatDateLong = (date: Date, lang: DateLocale): string => {
  return lang === 'ko'
    ? format(date, 'yyyy년 M월 d일 (E)', { locale: ko })
    : format(date, 'MMM d, yyyy (EEE)', { locale: enUS });
};

/**
 * Format month-year e.g. "Dec 2024" or "2024년 12월"
 */
export const formatMonthYear = (date: Date, lang: DateLocale): string => {
  return lang === 'ko'
    ? format(date, 'yyyy년 M월', { locale: ko })
    : format(date, 'MMM yyyy', { locale: enUS });
};

/**
 * Format short weekday (1 char) for calendar
 */
export const formatShortWeekday = (date: Date, lang: DateLocale): string => {
  return format(date, 'E', { locale: lang === 'ko' ? ko : enUS }).slice(0, 1);
};

// Re-export date-fns functions for convenience
export { format, parseISO } from 'date-fns';
export { ko, enUS } from 'date-fns/locale';

/**
 * Check if cache is still valid (same day)
 */
export const isCacheValid = (cachedDate: string): boolean => {
  return cachedDate === getTodayDateString();
};



===== FILE: src\utils\format.ts =====
/**
 * Format seconds to MM:SS format
 */
export const formatTime = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
};

/**
 * Format duration between two timestamps
 */
export const formatDuration = (start: string, end: string | null): string => {
  if (!end) return "Unknown";
  const diff = new Date(end).getTime() - new Date(start).getTime();
  const minutes = Math.floor(diff / 1000 / 60);
  return `${minutes}m`;
};

/**
 * Format date to relative string (Today, Yesterday, or MM/DD)
 */
export const formatDate = (dateStr: string): string => {
  const date = new Date(dateStr);
  const now = new Date();
  const isToday = date.toDateString() === now.toDateString();

  if (isToday) return "Today";
  
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (date.toDateString() === yesterday.toDateString()) return "Yesterday";

  return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
};

/**
 * Get shortened workout name (first 2 characters)
 */
export const getWorkoutNameShort = (name: string | null): string | null => {
  if (!name) return null;
  return name.length >= 2 ? name.substring(0, 2) : name;
};



===== FILE: src\utils\index.ts =====
// Date utilities
export {
  getTodayDateString,
  getWeekRange,
  getTodayRange,
  getWeekDays,
  getDayLabel,
  formatDateLong,
  formatMonthYear,
  formatShortWeekday,
  isCacheValid,
  format,
  parseISO,
  ko,
  enUS,
  type DateLocale,
} from './date';

// Format utilities
export {
  formatTime,
  formatDuration,
  formatDate,
  getWorkoutNameShort,
} from './format';